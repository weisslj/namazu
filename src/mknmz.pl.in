#! @PERL@ -w
# -*- Perl -*-
# mknmz - indexer of Namazu
# $Id: mknmz.pl.in,v 1.74 1999-11-05 05:29:53 masao Exp $
#
# Copyright (C) 1997-1999 Satoru Takabayashi  All rights reserved.
#     This is free software with ABSOLUTELY NO WARRANTY.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either versions 2, or (at your option)
#  any later version.
# 
#  This program is distributed in the hope that it will be useful
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
#  02111-1307, USA
#
#  This file must be encoded in EUC-JP encoding
#

package mknmz;
require 5.004;
use lib "@ADDITIONAL_INC@";
use Cwd;
use IO::File;
use Time::Local;
use File::MMagic;
use strict;  # be strict since v1.2.0
use Getopt::Long;

use vars qw($SYSTEM);
$SYSTEM = $^O;

my $LANG = "C";                # language of messages
my $CCS = "euc";
my $CONFDIR  = "%CONFDIR%";    # directory where mknmzrc are in.
my $LIBDIR  = "%LIBDIR%";      # directory where library etc. are in.
my $FILTERDIR  = "%FILTERDIR%";      # directory where filters are in.
my $TEMPLATEDIR  = "%TEMPLATEDIR%";  # directory where templates are in.

my $DeletedFilesCount = 0;
my $UpdatedFilesCount = 0;
my $APPENDMODE = 0;
my %PhraseHash = ();
my %PhraseHashLast = ();
my %KeyIndex = ();
my %KeyIndexLast = ();
my %CheckPoint = ("on" => undef, "continue" => undef);
my $ConfigFile = undef;
my $MediaType  = undef;

my $ReplaceCode  = undef;  # perl code for transforming URI
my @Seed = ();

my $Magic = new File::MMagic;

STDOUT->autoflush(1);
main();
sub main () {
    my $start_time = time;

    init();
    setup_magic();
    load_modules();
    my $file_base = prep();
    read_config();

    my $swap = 1;
    my $file_count = 0;
    my $total_files_size = 0;
    my $key_count = 0;
    my $checkpoint = 0;
    my $flist_ptr = 0;
    my $processed_files_size = 0;

    # Restore variables
    eval util::readfile($var::NMZ{'_checkpoint'}) if $CheckPoint{'continue'};

    {
	my $fh_errorsfile = util::efopen(">>$var::NMZ{'err'}");
	my $fh_flist = util::efopen($var::NMZ{'_flist'});
	my %field_indices = ();
	get_field_index_base(\%field_indices);

	if ($CheckPoint{'continue'}) {
	    seek($fh_flist, $flist_ptr, 0);
	}

	# Process target files one by one
	while (defined(my $line = <$fh_flist>)) {
	    $flist_ptr += length($line);
	    my $cfile = $line;
	    chomp $cfile;
	    my $cfile_size = namazu_core($cfile, $file_count, $file_base, 
				 \%field_indices, $fh_errorsfile);
	    next unless $cfile_size;
	    put_registry($cfile);

	    $total_files_size     += $cfile_size;
	    $processed_files_size += $cfile_size;
	    $file_count++;
	    if ($processed_files_size > $conf::ON_MEMORY_MAX) {
		if (%KeyIndex) {
		    $key_count = write_index();
		    write_phrase_hash();
		}
		$processed_files_size = 0;
		$checkpoint = 1, last if $CheckPoint{'on'} && defined(<$fh_flist>);
	    }
	}
    }
    # This should be out of above blocks because of file handler closing.
    re_exec($flist_ptr, $file_count, $file_base, 
	    $start_time, $total_files_size) if $checkpoint;

    if (%KeyIndex) {
	$key_count = write_index();
	write_phrase_hash();
    }

    $key_count = get_total_keys() unless $key_count;
    do_remain_job($total_files_size, $file_count, $key_count, 
		   $start_time);
    exit 0;
}

sub read_config () {
    my (@cand) = ();
    push @cand, $ConfigFile if defined $ConfigFile;
    push @cand, "$ENV{'HOME'}/.mknmzrc", "$CONFDIR/mknmzrc";

    for my $conf (@cand) {
	if (-f $conf) {
	    util::vprint("conf: $conf\n");
	    do $conf;
	    $ConfigFile = $conf;
	    return;
	}
    }
}

sub re_exec($$$$) {
    my ($flist_ptr, $file_count, $file_base, $start_time, $total_files_size) = @_;

    # store variables
    {
	my $fh_checkpoint = util::efopen(">$var::NMZ{'_checkpoint'}");

	print $fh_checkpoint <<EOM;
	\$DeletedFilesCount = $DeletedFilesCount;
	\$UpdatedFilesCount = $UpdatedFilesCount;
	\$APPENDMODE = $APPENDMODE;
	\$flist_ptr = $flist_ptr;
	\$file_count = $file_count;
	\$file_base = $file_base;
	\$start_time = $start_time;
	\$total_files_size = $total_files_size;
	\$\$ = $$;
EOM
    }

    @ARGV = ("-S", @ARGV) ;
    print "Checkpoint reached: re-exec mknmz...\n" unless $var::Opt{'quiet'};
    util::dprint(join ' ', ("::::", @ARGV, "\n"));
    exec ($0, @ARGV) ;
}

sub put_registry ($) {
    my ($filename) = @_;
    my $fh_registry = util::efopen(">>$var::NMZ{'_r'}");
    print $fh_registry $filename, "\n";
}


# Initialization
#   $CCS: Character Coding System 'euc' or 'sjis'
sub init () {
    $SYSTEM = $^O;
    if (($SYSTEM eq "MSWin32") || ($SYSTEM eq "os2")) {
	$CCS = "sjis";
	if ($LIBDIR !~ /^[A-Z]:/i && $0 =~ m#^([A-Z]:)(/|\\)#i) {
	    $LIBDIR = $1 . $LIBDIR ;
	}
    } else {
	$CCS = "euc";
    }

    # set LANG
    for my $cand (("LC_ALL", "LC_MESSAGES", "LANG")) {
	if (defined($ENV{$cand})) {
	    $LANG = $ENV{$cand};
	    last;
	}
    }
    # print "LANG: $LANG\n";

    $SIG{'INT'}  = sub {
	util::cdie("SIGINT caught! Aborted.\n");
    };
}

sub load_modules () {
    unshift @INC, $LIBDIR;
    unshift @INC, $FILTERDIR;

    require "var.pl";
    require "conf.pl";
    require "util.pl";
    require "usage.pl";
    require "codeconv.pl";
    require "find.pl";
    require "wakati.pl";
    require "seed.pl";
    @Seed = seed::init();

    # Check filter modules
    my @filters = ();
    @filters = glob "$FILTERDIR/*.pl" if @filters == 0;

    for my $filter (@filters) {
	$filter =~ m!(\w+)\.pl$!;
	my $module = $1;
	next if ($module eq 'gfilter'); # skip gfilter (not for filtering)
	require "$module.pl";
	my (@mtypes, $status, $recursive, $codeconv);
	eval "\@mtypes =    ${module}::mediatype();";
	eval "\$status =    ${module}::status();";
	eval "\$recursive = ${module}::recursive();";
	eval "\$codeconv  = ${module}::codeconv();";
	for my $mt (@mtypes) {
	    $var::Supported{$mt} = $status;
	    $var::REQUIRE_ACTIONS{$mt} = $module;
	    $var::RECURSIVE_ACTIONS{$mt} = $recursive if ($recursive);
	    $var::REQUIRE_CODECONV{$mt} = $codeconv if ($codeconv);
	}
    }
}

# Core routine
sub namazu_core ($$$) {
    my ($cfile, $file_count, $file_base, $field_indices, 
	$fh_errorsfile) = @_;

    my $headings = "";
    my $content = "";
    my $weighted_str = "";
    my %fields;

    my $uri = generate_uri($cfile);  # Make a URI from a file name
    my ($cfile_size, $text_size, $kanji, $mtype) = 
	load_document(\$cfile, \$content, \$weighted_str,
		      \$headings, \%fields);

    # check if the file is acceptable.
    my $err = check_file($cfile, $text_size, $mtype);
    if (defined $err) {
	print $file_count + $file_base . " $uri $err\n" unless $var::Opt{'quiet'};
	print $fh_errorsfile "$cfile $err\n"; 
	return 0;  # return 0 if error
    }

    # check if the file should be excluded.
    $err = isexcluded($cfile, $uri, \$content);
    if (defined $err) {
	print $file_count + $file_base . 
	    " $uri $err\n" unless $var::Opt{'quiet'};
	print $fh_errorsfile "$cfile $err\n"; 
	return 0;  # return 0 if error
    }

    # Output processing file name as URI
    print $file_count + $file_base . 
	" $uri [$mtype]\n" unless $var::Opt{'quiet'};

    complete_field_info(\%fields, $cfile, $uri, 
			\$headings, \$content, \$weighted_str);
    put_field_index(\%fields, $field_indices);

    put_dateindex($cfile);
    $content .= $weighted_str;   # add weights
    count_words($file_count, $file_base, \$content, $kanji);
    make_phrase_hash($file_count, $file_base, \$content);

    return $cfile_size;
}

# Check wheter or not the given URI is excluded.
sub isexcluded ($$$) {
    my ($cfile, $uri, $contref) = @_;
    my $err = undef;

    if ($var::Opt{'robotexclude'}) {
	if ($uri =~ m/^$conf::ROBOTS_EXCLUDE_URIS/io) {
	    $err = "is excluded because of /robots.txt.\n";
	} elsif ($cfile =~ /\.($conf::HTML_SUFFIX)$/io &&
		 $$contref =~ /META\s+NAME\s*=\s*([\'\"]?)ROBOTS\1\s+[^>]*
		 CONTENT\s*=\s*([\'\"]?).*?(NOINDEX|NONE).*?\2[^>]*>/ix)  #"
	{
	    $err = "is excluded because of <META> element.";
	}
    }

    return $err;

}

# make a URI from a file name
sub generate_uri ($) {
    my ($file) = @_;
    return undef unless defined $file;
    my $uri = $file;

    if ($var::Opt{'ommit'}) {
    }

    if (defined $ReplaceCode) {
	# omit a file name if omittable
	$uri =~ s!(.*)/($conf::DEFAULT_FILE)$!$1/!o; 

	# transforming URI by evaling
	$_ = $uri;
	eval $ReplaceCode;
	$uri = $_;
    }

    if (($SYSTEM eq "MSWin32") || ($SYSTEM eq "os2")) {
	$uri =~ s#^([A-Z]):#/$1|#i; # converting a drive part like: /C|
    }

    unless ($var::Opt{'noencodeuri'}) {
	# Escape unsafe characters (not strict)
	$uri =~ s/\%/%25/g;  # Convert original '%' into '%25' v1.1.1.2
	$uri =~ s/([^a-zA-Z0-9~\-\_\.\/\:\%])/
	    sprintf("%%%02X",ord($1))/ge;
	if (($SYSTEM eq "MSWin32") || ($SYSTEM eq "os2")) {
	    # restore '|' for drive letter rule of Win32, OS/2
	    $uri =~ s!^/([A-Z])%7C!/$1|!i;
	}
    }
    return $uri;
}


sub get_field_index_base (\%) {
    my ($field_indices) = @_;

    my @keys = split('\|', $conf::SEARCH_FIELD);
    if ($var::Opt{'meta'}) {
	push @keys, (split '\|', $conf::META_TAGS);
    }
    for my $key (@keys) {
	$key = lc($key);
	my $fname    = "$var::NMZ{'field'}.$key";
	my $tmp_fname = util::tmpnam("NMZ.field.$key");
	my $size = 0;
	$size = -s $fname if -f $fname;
	$size += -s $tmp_fname if -f $tmp_fname;
	$field_indices->{$key} = $size;
    }
}

sub complete_field_info (\%$$\$\$\$) {
    my ($fields, $cfile, $uri, $headings, $contref, $wsref) = @_;

    unless (defined($fields->{'title'})) {
	$fields->{'title'} = gfilter::filename_to_title($cfile, $wsref);
    }
    unless (defined($fields->{'date'})) {
	my $mtime = (stat($cfile))[9];
	my $date = util::rfc822time($mtime);
	$fields->{'date'} = $date;
    }
    unless (defined($fields->{'uri'})) {
	$fields->{'uri'} = $uri;
    }
    unless (defined($fields->{'size'})) {
	$fields->{'size'} = -s $cfile;
    }
    unless (defined($fields->{'summary'})) {
	$fields->{'summary'} = make_summary($contref, $headings, $cfile);
    }
    unless (defined($fields->{'from'}) || defined($fields->{'author'})) {
	$fields->{'from'} = "(unknown)";
    }
}

sub make_summary ($$$) {
    my ($contref, $headings, $cfile) = @_;

    # pick up $conf::SUMMARY_LENGTH bytes string
    my $tmp = "";
    if ($$headings ne "") {
	$$headings =~ s/^\s+//;
	$$headings =~ s/\s+/ /g;
	$tmp = $$headings;
    } else {
	$tmp = "";
    }

    my $offset = 0;
    my $tmplen = 0;
    while (($tmplen = $conf::SUMMARY_LENGTH + 1 - length($tmp)) > 0
           && $offset < length($$contref))
    {
        $tmp .= substr $$contref, $offset, $tmplen;
        $offset += $tmplen;
        $tmp =~ s/(([\xa1-\xfe]).)/$2 eq "\xa8" ? '': $1/ge;
        $tmp =~ s/([-=*\#])\1{2,}/$1$1/g;
    }

    my $summary = substr $tmp, 0, $conf::SUMMARY_LENGTH;
    my $kanji = $summary =~ tr/\xa1-\xfe/\xa1-\xfe/;
    $summary .= substr($tmp, $conf::SUMMARY_LENGTH, 1) if $kanji %2;

    $summary =~ s/^\s+//;
    $summary =~ s/\s+/ /g;   # normalize white spaces

    return $summary;
}


# output the field infomation into NMZ.fields.* files
sub put_field_index (\%$) {
    my ($fields, $field_indices) = @_;

    my $aliases_regex = 
	join('|', sort {length($b) <=> length($a)} keys %conf::FIELD_ALIASES);

    for my $field (keys %{$fields}) {
        util::dprint("Field: $field: $fields->{$field}\n");
	if ($field =~ /^($aliases_regex)$/o) {
	    unless (defined($fields->{$conf::FIELD_ALIASES{$field}})) {
		$fields->{$conf::FIELD_ALIASES{$field}} = $fields->{$field};
	    }
	    undef $fields->{$field};
	}
    }

    my @keys = split '\|', $conf::SEARCH_FIELD;
    if ($var::Opt{'meta'}) {
	push @keys, (split '\|', $conf::META_TAGS);
    }
    for my $key (@keys) {
	my $lkey = lc($key);
	my $fname    = util::tmpnam("NMZ.field.$lkey");
	my $fh_field = util::efopen(">>$fname");
	my $output = "";
	if (defined($fields->{$key})) {
	    $fields->{$key} =~ s/\s+/ /g;
	    $fields->{$key} =~ s/\s+$//;
	    $fields->{$key} =~ s/^\s+//;
	    $output = $fields->{$key} . "\n";
	    if (length($output) > 1024) {
		$output = substr $output, 0, 1022;
		$output .= "\n";
	    }
	} else {
	    $output = "\n";
	}
	print $fh_field $output;

	# put index of field index
	{
	    my $fname        = util::tmpnam("NMZ.field.$lkey.i");
	    my $fh_field_idx = util::efopen(">>$fname");
	    print $fh_field_idx pack("N", $field_indices->{$lkey});
	    $field_indices->{$lkey} += length $output;
	}
    }
}


# put the date infomation into NMZ.t file
sub put_dateindex ($) {
    my ($cfile) = @_;
    my $mtime = (stat($cfile))[9];

    my $fh_dataindex = util::efopen(">>$var::NMZ{'_t'}");
    print $fh_dataindex pack("N", $mtime);
}


# load a document file
sub load_document ($$$$\%) {
    my ($orig_cfile, $contref, $weighted_str, $headings, $fields)
      = @_;
    my $cfile = $$orig_cfile;

    return (0, 0, 0, 0) unless (-f $cfile && -r $cfile);

    # for handling a filename which contains Shift_JIS code
    my $shelter_cfile = "";
    if ($SYSTEM eq "MSWin32" 
	&& $cfile =~ /[\x81-\x9f\xe0-\xef][\x40-\x7e\x80-\xfc]|[\x20\xa1-\xdf]/) 
    {
	$shelter_cfile = $cfile;
	$cfile = util::tmpnam("NMZ.win32");
        util::cp($shelter_cfile, $cfile);
    }

    my $file_size;
    $file_size = util::filesize($cfile); # not only file in feature.
    if ($file_size > $conf::TEXT_SIZE_MAX) {
	return ($file_size, $file_size, 0, 'x-system/x-error');
    }
   $$contref = util::readfile($cfile);
#    $file_size = length($$contref);

    # filtering process
    my $mtype;
    while (1) {
	if (defined $MediaType) {
	    $mtype = $MediaType;
	} else {
	    my $mtype_n = $Magic->checktype_byfilename($cfile);
	    my $mtype_c = $Magic->checktype_data($$contref);
	    my $mtype_m;
	    $mtype_m = $Magic->checktype_magic($$contref) 
	      if ((! defined $mtype_c) || $mtype_c =~ /^(text\/html|text\/plain|application\/octet-stream)$/);
	    $mtype_c = $mtype_m if (defined $mtype_m && 
				    $mtype_m !~ /^(text\/html|text\/plain|application\/octet-stream)$/);
	    $mtype_c = 'text/plain' unless defined $mtype_c;
	    $mtype = decide_type($mtype_n, $mtype_c);
	}
	if (defined $var::REQUIRE_CODECONV{$mtype}) {
	      codeconv::toeuc($contref);
	      $$contref =~ s/[ \t]+/ /g;   # remain LFs v1.03
	      $$contref =~ s/\r\n/\n/g;    # remain LFs for ChaSen
	      $$contref =~ s/\r/\n/g;      # CR+LF or CR are into LF
	      # Control characters be into space
	      $$contref =~ tr/\x00-\x09\x0b-\x1f\x7f\xff/    /;
	}
	util::dprint("Detected type: $mtype\n");
	if (! defined $var::Supported{$mtype} || $var::Supported{$mtype} ne 'yes') {
	    util::vprint("Unsupported data type $mtype\n");
	    return ($file_size, $file_size, 0, "$mtype; x-system=unsupported");
	}
	if (defined $var::REQUIRE_ACTIONS{$mtype}) {
	    util::vprint("Using $var::REQUIRE_ACTIONS{$mtype}.pl\n");
	    require $var::REQUIRE_ACTIONS{$mtype}.'.pl';
	    my $err = undef;
	    eval '$err = ' . $var::REQUIRE_ACTIONS{$mtype} .
	      '::filter($orig_cfile, $contref, $weighted_str, $headings, $fields);';
	    if ($err) {
		return ($file_size, $file_size, 0, "$mtype; x-error=$err");
	    }
	    if ($@) {
		util::vprint("Faild to call $var::REQUIRE_ACTIONS{$mtype}\n$@\n");
		return ($file_size, $file_size, 0, "$mtype; x-error=$@");
	    }
	    next if (defined $var::RECURSIVE_ACTIONS{$mtype});
	}
	last;
    }

    # masure text size at this time
    my $text_size = length($$contref) + length($$weighted_str); 

    if ($SYSTEM eq "MSWin32" && $shelter_cfile ne "") {
	unlink $cfile;
	$cfile = $shelter_cfile;
    }

    my $kanji = $$contref =~ tr/\xa1-\xfe/\xa1-\xfe/;  # Kanji contained?
    $kanji += $$weighted_str =~ tr/\xa1-\xfe/\xa1-\xfe/;

    return ($file_size, $text_size, $kanji, $mtype);
}

sub prep () {
    my $file_base = 0;
    my $output_dir = "";
    my @targets = ();
    my @flist = ();

    ($output_dir, @targets) = parse_options();
    $var::OUTPUT_DIR = $output_dir;

    require_modules();
    change_dbnames();
    check_present_index();

    # if Checkpoint mode, return
    return 0 if $CheckPoint{'continue'};

    @flist = find_target(@targets);
    ($file_base, @flist) = append_index(@flist) 
	if -f $var::NMZ{'r'};
    unless (@flist) { # if @flist is empty
	print "No files to index.\n";
	exit 0;
    }
    set_lockfile($var::NMZ{'lock2'});
    save_flist(@flist);

    return $file_base;
}

sub save_flist(@) {
    my @flist = @_;
    return if (@flist == 0);

    my $fh_flist = util::efopen(">$var::NMZ{'_flist'}");
    print $fh_flist join("\n", @flist), "\n";
}

sub require_modules() {
    if (util::islang("ja") && $conf::NKF =~ /^module_nkf/) {
	require NKF;
        util::dprint("code conversion: using NKF module\n");
	$var::USE_NKF_MODULE = 1;
    }
    if (util::islang("ja") && $conf::WAKATI =~ /^module_kakasi/) {
	require Text::Kakasi;
        util::dprint("wakati: using Text::Kakasi module\n");
	my $res = Text::Kakasi::getopt_argv('kakasi', '-ieuc', '-oeuc', '-w');
    }
    if (util::islang("ja") && $conf::WAKATI =~ /^module_chasen1/) {
	require Text::ChaSen1;
        util::dprint("wakati: using Text::ChaSen1 module\n");
	my @arg = ('-j', '-F', '%m ');
	@arg    = ('-j', '-F', '%m %H\\n') if $var::Opt{'morph'};
	my $res = Text::ChaSen1::getopt_argv('chasen-perl', @arg);
    }
}

sub set_lockfile ($) {
    my ($file) = @_;

    # make a lock file
    if (-f $file) {
	print "$file found. Maybe this index is being updated by another process now.\nIf not, you can remove this file.\n";
	exit 1;
    } else {
	my $fh_lockfile = util::efopen(">$file");
	print $fh_lockfile "$$"; # save pid
    }
}

sub remove_lockfile ($) {
    my ($file) = @_;

    # remove lock file
    unlink $file if -f $file;
}

# check present index whether it is old type of not
sub check_present_index () {
    if (-f $var::NMZ{'i'} && ! -f "$var::NMZ{'result'}.normal") 
    {
	util::cdie("Present index is old type. it's unsupported.\n");
    }
}

# remain
sub do_remain_job ($$$$) {
    my ($total_files_size, $file_count, $key_count, $start_time) = @_;

    if ($file_count == 0) {
	# No files are indexed
	if ($DeletedFilesCount > 0) {
	    update_dateindex();
	    update_registry($file_count);
	}
    } else {
	set_lockfile($var::NMZ{'lock'});
	write_body_msg();
	write_tips_msg();
	write_result_file();
	update_field_index();
	update_dateindex();
	update_registry($file_count);
	write_nmz_files();
	make_slog_file();
	remove_lockfile($var::NMZ{'lock'});
    }
    make_headfoot_pages($file_count, $key_count);
    put_log($total_files_size, $start_time, $file_count, $key_count);
    util::remove_tmpfiles();
    unlink $var::NMZ{'_flist'};
}

sub make_headfoot_pages($$) {
    my ($file_count, $key_count) = @_;

    for my $file (glob "$TEMPLATEDIR/NMZ.head*") {
	$file =~ m!.*/NMZ.head(.*)$!;
	my $suffix = $1;
	make_headfoot("$var::NMZ{'head'}${suffix}", $file_count, $key_count);
    }
    for my $file (glob "$TEMPLATEDIR/NMZ.foot*") {
	$file =~ m!.*/NMZ.foot(.*)$!;
	my $suffix = $1;
	make_headfoot("$var::NMZ{'foot'}${suffix}", $file_count, $key_count);
    }
}

# parse comannd line options
sub parse_options ()
{
    if (@ARGV == 0) {
	show_mini_usage();
	exit 1;
    }

    my @targets = ();
    my $targets_loaded = 0;
    my @argv = @ARGV;
    my $cwd = cwd();

    my $opt_dummy = 0;
    my $opt_version = 0;
    my $opt_help = 0;
    my $opt_all = 0;
    my $opt_chasen = 0;
    my $opt_chasen_morph = 0;
    my $opt_kakasi = 0;
    my $opt_checkpoint_sub = 0;
    my $opt_show_config = 0;
    my $opt_mailnews = 0;
    my $opt_mhonarc = 0;

    my $output_dir = undef;
    my $update_index = undef;
    my $include_file = undef;
    my $target_list = undef;

#    Getopt::Long::Configure('bundling');
    Getopt::Long::config('bundling');
    GetOptions(
       	       '0|help'              => \$opt_help,
	       '1|exclude=s'         => \$conf::EXCLUDE_REGEX,
	       '2|deny=s'            => \$conf::DENY_REGEX,
	       '3|allow=s'           => \$conf::ALLOW_REGEX,
	       '4|update=s'          => \$update_index,
	       '5|mhonarc'           => \$opt_mhonarc,
	       'A|htacces'           => \$var::Opt{'htaccessexclude'},
	       'C|show-config'       => \$opt_show_config,
	       'E|no-edge-symbol'    => \$var::Opt{'noedgesymbol'},
	       'F|target-list=s'     => \$target_list,
	       'G|no-okurigana'      => \$var::Opt{'okurigana'},
	       'H|no-hiragana'       => \$var::Opt{'hiragana'},
	       'I|include=s'         => \$include_file,
	       'K|no-symbol'         => \$var::Opt{'nosymbol'},
	       'L|lang=s'            => \$LANG,
	       'M|meta'              => \$var::Opt{'meta'},
	       'O|output-dir=s'      => \$output_dir,
	       'S|checkpoint-sub'    => \$opt_checkpoint_sub,
	       'T|template-dir=s'    => \$TEMPLATEDIR,
	       'U|no-encode-uri'     => \$var::Opt{'noencodeuri'} ,
	       'V|verbose'           => \$var::Opt{'verbose'},
	       'Y|no-delete'         => \$var::Opt{'nodelete'},
	       'Z|no-update'         => \$var::Opt{'noupdate'},
	       'a|all'               => \$opt_all,
	       'c|use-chasen'        => \$opt_chasen,
	       'd|debug'             => \$var::Opt{'debug'},
	       'e|robots-txt'        => \$var::Opt{'robotexclude'},
	       'f|config=s'          => \$ConfigFile,
	       'h|mailnews'          => \$opt_mailnews,
	       'k|use-kakasi'        => \$opt_kakasi,
	       'm|use-chasen-morph'  => \$opt_chasen_morph,
	       'q|quiet'             => \$var::Opt{'quiet'},
	       'r|replace=s'         => \$ReplaceCode,
	       's|checkpoint'        => \$CheckPoint{'on'},
	       't|media-type=s'      => \$MediaType,
	       'u|uuencode'          => \$opt_dummy, # for backward compat.
	       'v|version'           => \$opt_version,
	       'x|no-heading-summary'=> \$var::Opt{'noheadabst'},
	       );

    if ($opt_help) {
	show_long_usage();
	exit 0;
    }

    if ($opt_version) {
	print "mknmz v$var::VERSION\n";
	exit 0;
    }

    if ($opt_show_config) {
	read_config();
	show_config();
	exit 0;
    }

    if (defined $update_index) {
	my $orig_status = $var::NMZ{'status'};
	$var::NMZ{'status'} = "$update_index/$var::NMZ{'status'}";

	my $argv = get_status("argv");
	@ARGV = split /\t/, $argv;
	util::dprint("Inherited argv: @ARGV\n");

	my $cwd  = get_status("cwd");
	chdir $cwd;
	util::dprint("Inherited cwd: $cwd\n");

	($output_dir, @targets) = parse_options();
	$output_dir = $update_index;
	$var::NMZ{'status'} = $orig_status;  # See also change_dbnames()
	return ($output_dir, @targets);
    }

    if ($opt_mailnews) {
	$MediaType = 'message/rfc822';
    }
    if ($opt_mhonarc) {
	$MediaType = 'text/html; x-type=mhonarc';
    }
    if ($opt_all) {
	$conf::ALLOW_REGEX = ".*";
    }
    if ($opt_chasen) {
	$conf::WAKATI = $conf::CHASEN;
	$var::Opt{'morph'} = 0;
    }
    if ($opt_chasen_morph) {
	$conf::WAKATI = $conf::CHASEN_MORPH;
	$var::Opt{'morph'} = 1;
    }
    if ($opt_kakasi) {
	$conf::WAKATI = $conf::KAKASI;
	$var::Opt{'morph'} = 0;
    }
    if ($var::Opt{'robotexclude'}) {
        html::parse_robots_txt();
    }
    if ($include_file) {
	do $include_file;
        util::dprint("Included: $include_file\n");
    }
    if ($target_list) {
	if ($CheckPoint{'continue'}) {
	    @targets = ("dummy");
	} else {
	    @targets = load_target_list($target_list);
	    util::dprint("Loaded: $target_list\n");
	}
	$targets_loaded = 1;
    }
    if ($opt_checkpoint_sub) {
	$CheckPoint{'on'}           = 1;
	$CheckPoint{'continue'}     = 1;
	@argv = grep {! /-S/} @argv;  # remove -S
    }

    if (defined $ReplaceCode) {
	my $orig = "/foo/bar/baz/quux.html";
	$_ = $orig;
	eval $ReplaceCode;
	if ($@) {  # eval error
	    util::cdie("Invalid replace: $ReplaceCode\n");
	}
	util::dprint("Replace: $orig -> $_\n");
    }

    if (@ARGV == 0 && $targets_loaded == 0) {
	show_mini_usage();
	exit 1;
    }

    $output_dir = $cwd unless defined $output_dir;
    util::cdie("$output_dir: invalid output directory\n")
	unless (-d $output_dir && -w $output_dir);

    if ($SYSTEM eq "MSWin32" || $SYSTEM eq "os2") {
	# convert \ to / with consideration for Shift_JIS Kanji code
	$output_dir =~ 
	    s!([\x81-\x9f\xe0-\xef][\x40-\x7e\x80-\xfc]|[\x01-\x7f])!
	    $1 eq "\\" ? "/" : $1!gex;
    }

    # take remaining @ARGV as targets
    if (@ARGV > 0 && $targets_loaded == 0) {
	@targets = @ARGV ;
    }
    
    # revert @ARGV
    # unshift @ARGV, splice(@argv, 0, @argv - @ARGV);
    @ARGV = @argv;

    return ($output_dir, @targets);
}

sub show_config () {
    $ConfigFile = "(none)" unless defined $ConfigFile;
    print "Config: $ConfigFile\n";
    print "System: $SYSTEM\n" if $SYSTEM;
    print "Namazu: $var::VERSION\n" if $var::VERSION;
    print "Perl:   $]\n" if $];   # '$]' has a perl version
    print "NKF:    $conf::NKF\n" if $conf::NKF;
    print "KAKASI: $conf::KAKASI\n" if $conf::KAKASI;
    print "ChaSen: $conf::CHASEN\n" if $conf::CHASEN;
    print "Wakati: $conf::WAKATI\n" if $conf::WAKATI;
    print "Lang:   $LANG\n";
    print "CCS:    $CCS\n";
    print "CONFDIR:     $CONFDIR\n";
    print "LIBDIR:      $LIBDIR\n";
    print "FILTERDIR:   $FILTERDIR\n";
    print "TEMPLATEDIR: $TEMPLATEDIR\n";

    my @supported = sort grep { $var::Supported{$_} eq "yes" }
    keys %var::Supported;
    print "Supported media types: \n";
    for my $mtype (@supported) {
	print "  $mtype\n";
    }
}

sub load_target_list ($) {
    my ($file) = @_;
    my $fh_targets = util::efopen($file);
    my @targets = <$fh_targets>;
    chomp @targets; 
    return @targets;
}

# convert a relative path into an absolute path
sub absolute_path($$) {
    my ($cwd, $path) = @_;

    $path =~ s!^\./!$cwd/!;
    if (($SYSTEM eq "MSWin32") || ($SYSTEM eq "os2")) {
        $path =~ s,^([A-Z](?!:/)),$cwd/$1,i;
    } else {
        $path =~ s!^([^/])!$cwd/$1!; 
    }
    return $path;
}

sub find_target (@) {
    my @targets = @_;

    my $cwd = cwd();
    @targets = map { absolute_path($cwd, $_) } @targets;

    # convert \ to / with consideration for Shift_JIS encoding
    if (($SYSTEM eq "MSWin32") || ($SYSTEM eq "os2")) {
	grep {
	    $_ =~ s!([\x81-\x9f\xe0-\xef][\x40-\x7e\x80-\xfc]|[\x01-\x7f])!
	    $1 eq "\\" ? "/" : $1!gex;
	} @targets;
    }

    # traverse directories
    # this routine is not efficent but I prefer reliable logic.
    my @flist = ();
    while (@targets) {
	my $target = shift @targets;
	if (-d $target) { # target is a directory
	    my $cwd = cwd();
	    chdir $target;
	    find::findfiles(\@flist);
	    chdir $cwd;
	} else {
	    push(@flist, $target);
	}
    }

    return @flist;
}


sub show_long_usage () {
    util::dprint("lang: $LANG\n");
    if (util::islang("ja")) {
	if ($CCS eq "euc") {
	    print $usage::USAGE_JA;
	} elsif ($CCS eq "sjis") {
	    my $msg = codeconv::eucjp_to_shiftjis($usage::USAGE_JA);
	    print $msg;
	}
    } else {
	print $usage::USAGE_EN;
    }
}

sub show_mini_usage () {
    print $usage::USAGE_MINI;
}

# check the file -- 0: OK / 1: NG
sub check_file ($$$) {
    my ($cfile, $text_size, $mtype) = @_;

    my $msg = undef;
    if ($text_size == 0) {
	$msg = "is 0 size! skipped.";
    } elsif ($mtype =~ /^application\/octet-stream/) {
	$msg = "may be a BINARY file! skipped.";
    } elsif ($text_size > $conf::TEXT_SIZE_MAX) {
	$msg = "is too LARGE a text! skipped.";
    } elsif ($mtype =~ /; x-system=unsupported$/) {
	$mtype =~ s/; x-system=unsupported$//;
	$msg = "Unsupported data type ($mtype) skipped.";
    } elsif ($mtype =~ /; x-error=.*$/) {
	$mtype =~ s/^.*; x-error=(.*)$/$1/;
	$msg = $mtype;
    } elsif ($mtype =~ /^x-system/) {
	$msg = "system error occurred! ($mtype) skipped.";
    }

    return $msg;
}


# util::Rename *.$$ to each real file name
sub write_nmz_files () {
    util::Rename($var::NMZ{'_i'},   $var::NMZ{'i'});
    util::Rename($var::NMZ{'_ii'}, $var::NMZ{'ii'});
    util::Rename($var::NMZ{'_w'},  $var::NMZ{'w'});
    util::Rename($var::NMZ{'_wi'}, $var::NMZ{'wi'});
    util::Rename($var::NMZ{'_p'},  $var::NMZ{'p'});
    util::Rename($var::NMZ{'_pi'}, $var::NMZ{'pi'});
}

# output NMZ.body
sub write_body_msg () {
    for my $file (glob "$TEMPLATEDIR/NMZ.body*") {
	$file =~ m!.*/NMZ.body(.*)$!;
	my $suffix = $1;
	write_message("$var::NMZ{'body'}${suffix}");
    }
}

# output NMZ.tips
sub write_tips_msg () {
    for my $file (glob "$TEMPLATEDIR/NMZ.tips*") {
	$file =~ m!.*/NMZ.tips(.*)$!;
	my $suffix = $1;
	write_message("$var::NMZ{'tips'}${suffix}");
    }
}


# output NMZ.result.*
sub write_result_file () {
    my $fname = "NMZ.result.normal";

    my @files = glob "$TEMPLATEDIR/NMZ.result.*";

    for my $file (@files) {
	$file =~ m!(NMZ\.result\.[^/]*)$!;
	my $target = "$var::OUTPUT_DIR/$1";
	if (-f $target) {  # already exist;
	    next;
	} else {
	    my $buf = util::readfile($file);
	    my $fh_file = util::efopen(">$target");
	    print $fh_file $buf;
	}
    }
}

# write NMZ.body and etc.
sub write_message ($) {
    my ($msgfile) = @_;

    if (! -f $msgfile) {
	my ($template, $fname);
	
	$msgfile =~ m!.*/(.*)$!;
	$fname = $1;
	$template = "$TEMPLATEDIR/$fname";

	if (-f $template) {
	    my $buf = util::readfile($template);
	    my $fh_output;
	    if (util::islang("ja") && !$var::USE_NKF_MODULE) {
		$fh_output = util::efopen("|$conf::NKF -j >$msgfile");
	    } else {
		$fh_output = util::efopen(">$msgfile");
	    }
	    $buf = NKF::nkf("-j", $buf) if $var::USE_NKF_MODULE;

	    print $fh_output $buf;
	}
    }
}


# Make a file for logging
sub make_slog_file () {
    {
	my $fh_slogfile = util::efopen(">>$var::NMZ{'slog'}");
    }
    chmod 0666, $var::NMZ{'slog'};
}


# concatenate $CURRENTDIR to head of each files
sub change_dbnames ($) {
    my $dir = $var::OUTPUT_DIR;

    for my $key (sort keys %var::NMZ) {
	next if $key =~ /^_/;    # exclude temporary file
	$var::NMZ{$key} = "$dir/$var::NMZ{$key}";
    }

    # temporary files
    for my $key (sort keys %var::NMZ) {
	if ($key =~ /^_/) {
	    $var::NMZ{$key} = util::tmpnam($var::NMZ{$key});
	}
    }

    if ($var::Opt{'debug'}) {
	for my $key (sort keys %var::NMZ) {
	    util::dprint("NMZ: $var::NMZ{$key}\n");
	}
    }
}


# for "find"
sub wanted ($$){
    my ($name, $rarray) = @_;

    return if (defined $conf::EXCLUDE_REGEX && $name =~ /$conf::EXCLUDE_REGEX/);
    
    if ($name !~ m!^.*/(($conf::DENY_REGEX)(\.gz|\.Z)?)$!i &&
	$name =~ m!^.*/(($conf::ALLOW_REGEX)(\.gz|\.Z|\?.*)?)$!i && 
	-f $name && -r $name)
    {
	push(@{$rarray}, $name);
	util::dprint("wanted: $name\n");
    }
}

#
# preparation processing for appending index files
#
sub append_index (@) {
    my @flist = @_;

    my $file_base = 0;
    ($file_base, @flist) = set_target_files(@flist);

    unless (@flist) { 	# if @flist is empty
	if ($DeletedFilesCount > 0) {
	    make_headfoot_pages(0, 0);
	    set_lockfile($var::NMZ{'lock2'});
	    update_dateindex();
	    update_registry(0);
	    put_log(0, 0, 0, get_total_keys());
	    util::remove_tmpfiles();
	}
	print "No files to index.\n";
	exit 0;
    }

    $APPENDMODE = 1;
    # conserve files by copying
    util::cp($var::NMZ{'i'},  $var::NMZ{'_i'});
    util::cp($var::NMZ{'w'},  $var::NMZ{'_w'});
    util::cp($var::NMZ{'t'},  $var::NMZ{'_t'}) 
	unless -f $var::NMZ{'_t'}; # preupdated ?
    util::cp($var::NMZ{'p'},  $var::NMZ{'_p'});
    util::cp($var::NMZ{'pi'}, $var::NMZ{'_pi'});

    return ($file_base, @flist);
}

# set target files to @flist and return with the regiested files number
sub set_target_files() {
    my %rfiles;    # 'rfiles' means 'registered files'
    my @found_files = @_;

    # load the list of registered files
    $rfiles{'name'} = [ load_registry() ];

    # pick up overlap files and do marking
    my %mark1;
    my @overlapped_files;
    grep($_ !~ /^\# / && $mark1{$_}++, @{$rfiles{'name'}});
    $rfiles{'overlapped'} = {}; # prepare an anonymous hash
    for (grep ($mark1{$_}, @found_files)) {
	$rfiles{'overlapped'}{$_} = 1;
	push(@overlapped_files, $_);
    };
    # pick up not overlapped files which are files to index
    my @flist = grep(! $mark1{$_}, @found_files);
	 
    if ($var::Opt{'noupdate'}) {
	return (scalar @{$rfiles{'name'}}, @flist);
    };

    # load the date index
    $rfiles{'mtime'} = [ load_dateindex() ];

    if (@{$rfiles{'mtime'}} == 0) {
	return (scalar @{$rfiles{'name'}}, @flist); 
    };

    if (@{$rfiles{'name'}} != @{$rfiles{'mtime'}}) {
	util::dprint("\n\n== registered ==\n", join("\n", @{$rfiles{'name'}}));
	util::dprint("\n\n== mtimes ==\n", join("\n", @{$rfiles{'mtime'}}));
	util::cdie("NMZ.r ($#{$rfiles{'name'}}) and NMZ.t ($#{$rfiles{'mtime'}}) are not consistent!\n");
    }

    # pick up deleted files and do marking
    # (registered in the NMZ.r but not existent in the filesystem)
    my @deleted_files;
    unless ($var::Opt{'nodelete'}) {
	my %mark2;
	grep($mark2{$_}++, @found_files);
	for (grep($_ !~ /^\# / && ! $mark2{$_} && ! $rfiles{'overlapped'}{$_}
		      , @{$rfiles{'name'}})) 
	{
	    $rfiles{'deleted'}{$_} = 1;
	    push(@deleted_files, $_);
	}
    }

    # pick up updated files and set the missing number for deleted files
    my @updated_files = pickup_updated_files(\%rfiles);

    # append updated files to list of files to index
    if (@updated_files) {
	push(@flist, @updated_files);
    }

    util::dprint("\n\n== found ==\n", join("\n", @found_files), "\n");
    util::dprint("\n\n== registered ==\n", join("\n", @{$rfiles{'name'}}), "\n");
    util::dprint("\n\n== overlapped  ==\n", join("\n", @overlapped_files), "\n");
    util::dprint("\n\n== deleted  ==\n", join("\n", @deleted_files), "\n");
    util::dprint("\n\n== updated ==\n", join("\n", @updated_files), "\n");
    util::dprint("\n\n== files to index ==\n", join("\n", @flist), "\n");

    # update NMZ.t with the missing number infomation and
    # append updated files and deleted files to NMZ.r with leading '# '
    if (@updated_files || @deleted_files) {
	$DeletedFilesCount = 0;
	$UpdatedFilesCount = 0;
	$UpdatedFilesCount += @updated_files;
#	$DeletedFilesCount += @updated_files;
	$DeletedFilesCount += @deleted_files;
	preupdate_dateindex(@{$rfiles{'mtime'}});
	preupdate_registry(@updated_files, @deleted_files);
    }

    # return with number of registered files and list of files to index
    return (scalar @{$rfiles{'name'}}, @flist);
}

sub preupdate_registry(@) {
    my (@list) = @_;

    my $fh_registry = util::efopen(">$var::NMZ{'_r'}");
    @list = grep(s/(.*)/\# $1\n/, @list);
    print $fh_registry @list;
    print $fh_registry "## deleted: " . util::rfc822time(time()) . "\n\n";
}

sub preupdate_dateindex(@) {
    my @mtimes = @_;

    # Since rewriting the entire file, it is not efficient, 
    # but simple and reliable. this would be revised in the future.
    my $fh_dateindex = util::efopen(">$var::NMZ{'_t'}");
#    print "\nupdate_dateindex\n", join("\n", @mtimes), "\n\n";
    print $fh_dateindex pack("N*", @mtimes);
}

sub update_registry ($) {
    my ($file_count) = @_;

    {
	my $fh_registry = util::efopen(">>$var::NMZ{'r'}");
	my $fh_registry_ = util::efopen($var::NMZ{'_r'});
	while (defined(my $line = <$fh_registry_>)) {
	    print $fh_registry $line;
	}
	if ($file_count > 0) {
	    print $fh_registry "## indexed: " . util::rfc822time(time()) . "\n\n";
	}
    }
    unlink $var::NMZ{'_r'};
}

sub update_dateindex () {
    util::Rename($var::NMZ{'_t'}, $var::NMZ{'t'});
}

sub update_field_index () {
    my @list = glob "$var::NMZ{'field'}.*.$$.tmp";
    for my $tmp (@list) {
	if ($tmp =~ m!((^.*/NMZ\.field\.[^\.]+(?:\.i)?)\.$$\.tmp)!) {
	    my $fname_tmp = $1;
	    my $fname_out = $2;
	    {
		my $fh_field = util::efopen(">>$fname_out");
		my $fh_tmp = util::efopen($fname_tmp);

		while (defined(my $line = <$fh_tmp>)) {
		    print $fh_field $line;
		}
	    }
	    unlink $fname_tmp;
	} else {
	    util::cdie("update_field_index: @list");
	}
    }
}

sub pickup_updated_files (\%) {
    my ($ref) = @_;
    my @updated_files = ();

    my $i = 0;
    for my $cfile (@{$ref->{'name'}}) {
	if (defined($ref->{'deleted'}{$cfile})) {
	    print "$cfile was deleted!\n" unless $var::Opt{'quiet'};
	    $ref->{'mtime'}[$i] = -1; # assign the a messing number
	} elsif (defined($ref->{'overlapped'}{$cfile})) {
	    my $cfile_mtime = (stat($cfile))[9];
	    my $rfile_mtime = $ref->{'mtime'}[$i];

	    if ($rfile_mtime < $cfile_mtime) {
		# this file is updated!
		print "$cfile was updated!\n" unless $var::Opt{'quiet'};
		$ref->{'mtime'}[$i] = -1; # assign the messing number
		push(@updated_files, $cfile);
	    }
	}
	$i++;
    }

    return @updated_files
}

sub load_dateindex() {
    my $fh_dateindex = util::efopen($var::NMZ{'t'});

    my $size = -s $var::NMZ{'t'};
    my $buf  = "";
    read($fh_dateindex, $buf, $size);
    my @list = unpack("N*", $buf);  # load date index
#    print "\nload_dateindex\n", join("\n", @list), "\n\n";

    return @list;
}

sub load_registry () {
    my @list = ();

    my $fh_registry = util::efopen($var::NMZ{'r'});

    my $i = 0;
    my %mark;
    while (defined(my $line = <$fh_registry>)) {
	chomp($line);
	next if $line =~ /^\s*$/; # an empty line
	next if $line =~ /^##/; # a comment
	if ($line =~ /^\#\s+(.*)/) {  # deleted document
	    my $tmp = $1;
	    # remove previous registration
	    if (defined($mark{$tmp})) {
		splice(@list, $mark{$tmp}, 1, "# $tmp");
		undef $mark{$tmp};
	    } else {
		util::cdie("ERROR: malformed NMZ.r format!\n");
	    }
	} else {
	    unless (defined($mark{$line})) {
		push(@list, $line);
		$mark{$line} = $i;
		$i++;
	    } 
	}
    }
    return @list;
}

sub get_total_keys() {
    my $keys = get_status("keys");
    $keys = 0 unless defined $keys;
    return $keys;
}

sub get_total_files() {
    my $files = get_status("files");
    $files = 0 unless defined $files;
    return $files;
}

sub get_status($) {
    my ($key) = @_;

    my $fh = util::fopen($var::NMZ{'status'});
    return undef unless defined $fh;

    while (defined(my $line = <$fh>)) {
	if ($line =~ /^$key\s+(.*)$/) {
	    util::dprint("status: $key = $1\n");
	    return $1;
	}
    }
    return undef;
}

sub put_total_files($) {
    my ($number) = @_;
    $number =~ tr/,//d;
    put_status("files", $number);
}

sub put_total_keys($) {
    my ($number) = @_;
    $number =~ tr/,//d;
    put_status("keys", $number);
}

sub put_status($$) {
    my ($key, $value) = @_;

    # remove NMZ.status file if the file has a previous value.
    unlink $var::NMZ{'status'} if defined get_status($key);

    my $fh = util::efopen(">> $var::NMZ{'status'}");
    print $fh "$key $value\n";
}

# do logging
sub put_log ($$$$) {
    my ($total_files_size, $start_time, $file_count, $total_keys_count) = @_;

    my $date = localtime;
    my $added_files_count   = util::commas($file_count - $UpdatedFilesCount);
    my $deleted_files_count = util::commas($DeletedFilesCount);
    my $updated_files_count = util::commas($UpdatedFilesCount);
    my $total_files_count   = util::commas(get_total_files() + $file_count 
					   - $DeletedFilesCount - $UpdatedFilesCount);
    my $added_keys_count    = 0;
    $added_keys_count       = util::commas($total_keys_count - get_total_keys());

    my $processtime         = time - $start_time;
    $processtime            = 0 if $start_time == 0;
    $total_files_size        = util::commas($total_files_size);
    $total_keys_count       = util::commas($total_keys_count);

    my $logmsg = "[Base]\n";
    $logmsg = "[Append]\n" if $APPENDMODE;
    $logmsg .= "Date: $date\n" if $date;
    $logmsg .= "Added Files: $added_files_count files\n" if $added_files_count;
    $logmsg .= "Deleted Files: $deleted_files_count files\n" if $deleted_files_count;
    $logmsg .= "Updated Files: $updated_files_count files\n" if $updated_files_count;
    $logmsg .= "Total Files: $total_files_count files\n" if $total_files_count;
    $logmsg .= "Size: $total_files_size bytes\n" if $total_files_size;
    $logmsg .= "Added Keywords: $added_keys_count words\n" if $added_keys_count;
    $logmsg .= "Total Keywords: $total_keys_count words\n" if $total_keys_count;
    $logmsg .= "Perl: $]\n" if $];   # '$]' has a perl version
    $logmsg .= "Namazu: $var::VERSION\n" if $var::VERSION;
    $logmsg .= "System: $SYSTEM\n" if $SYSTEM;
    $logmsg .= "Wakati: $conf::WAKATI\n" if $conf::WAKATI;
    $logmsg .= "Time: $processtime sec.\n"if $processtime;
    $logmsg .= "\n";

    print $logmsg unless $var::Opt{'quiet'};
    put_log_to_logfile($logmsg);
    put_total_files($total_files_count);
    put_total_keys($total_keys_count);

    my $argv = join "\t", @ARGV;
    my $cwd  = cwd();
    put_status("argv", $argv);
    put_status("cwd",  $cwd);
}

sub put_log_to_logfile ($) {
    my ($logmsg) = @_;
    my $fh_logfile = util::efopen(">>$var::NMZ{'log'}");
    print $fh_logfile $logmsg;
}

sub get_year() {
    my $year = (localtime)[5] + 1900;

    return $year;
}

# Compose NMZ.head and NMZ.foot. Prepare samples if necessary.
# Insert $file_count, $key_count, and $month/$day/$year respectively.
sub make_headfoot ($$$) {
    my ($file, $file_count, $key_count) = @_;

    my $day   = sprintf("%02d", (localtime)[3]);
    my $month = sprintf("%02d", (localtime)[4] + 1);
    my $year  = get_year();
    my $buf   = "";

    if (-f $file) {
	$buf = util::readfile($file);
    } else {
	$file =~ m!.*/(.*)$!;
	my $fname = $1;
	my $template = "$TEMPLATEDIR/$fname";

	if (-f $template) {
	    $buf = util::readfile($template);
	} else {
	    return;
	}
    }

    # the file must be saved in ISO-2022-JP encoding.
    my $fh_file;
    if (util::islang("ja") && !$var::USE_NKF_MODULE) {
	$fh_file = util::efopen("|$conf::NKF -j >$file");
    } else {
	$fh_file = util::efopen(">$file");
    }

    if ($buf =~ /(<!-- FILE -->)\s*(.*)\s*(<!-- FILE -->)/) {
	my $total_files_count = util::commas(get_total_files() + $file_count 
				   - $DeletedFilesCount - $UpdatedFilesCount);
	$buf =~ s/(<!-- FILE -->)(.*)(<!-- FILE -->)/$1 $total_files_count $3/;

    }
    if ($buf =~ /(<!-- KEY -->)\s*(.*)\s*(<!-- KEY -->)/) {
	my $tmp = $2;
	$tmp =~ tr/,//d;
	$tmp = $key_count;
	$tmp = util::commas($tmp);
	$buf =~ s/(<!-- KEY -->)(.*)(<!-- KEY -->)/$1 $tmp $3/;
    }
    $buf =~ s#(<!-- DATE -->)(.*)(<!-- DATE -->)#$1 $year-$month-$day $3#g;
    $buf =~ s/(<!-- VERSION -->)(.*)(<!-- VERSION -->)/$1 v$var::VERSION $3/g;

    $buf = NKF::nkf("-j", $buf) if $var::USE_NKF_MODULE;
    print $fh_file $buf;
}

# Make phrase hashes for NMZ.p
# Handle two words each for calculating a hash value ranged 0-65535.
sub make_phrase_hash ($$$) {
    my ($file_count, $file_base, $contref) = @_;

    my %tmp = ();
    $$contref =~ s!\x7f */? *\d+ *\x7f!!g;  # remove tags of weight
    $$contref =~ tr/\xa1-\xfea-z0-9 \n//cd; # remove all symbols
    my @words = split(/\s+/, $$contref);
    @words = grep {$_ ne ""} @words;   # remove empty words
    my $word_b = shift @words;
    my $docid = $file_count + $file_base;
    for my $word (@words) {
	my $hash = hash($word_b . $word);
	unless (defined $tmp{$hash}) {
	    $tmp{$hash} = 1;
	    $PhraseHashLast{$hash} = 0 unless defined $PhraseHashLast{$hash};
	    $PhraseHash{$hash} .= pack("w", $docid - $PhraseHashLast{$hash});
#	    util::dprint("<$word_b, $word> $hash\n");
	    $PhraseHashLast{$hash} = $docid;
	}
	$word_b = $word;
    }
}

# Construct NMZ.p and NMZ.pi file. this processing is rather complex.
sub write_phrase_hash () {
    write_phrase_hash_sub();
    util::Rename($var::NMZ{'__p'}, $var::NMZ{'_p'});
    util::Rename($var::NMZ{'__pi'}, $var::NMZ{'_pi'});
}

sub write_phrase_hash_sub () {
    my $opened = 0;

    return 0 if %PhraseHash eq "0";
    util::dprint("doing write_phrase_hash() processing.\n");

    my $fh_tmp_pi = util::efopen(">$var::NMZ{'__pi'}");
    my $fh_tmp_p  = util::efopen(">$var::NMZ{'__p'}");

    my $fh_phrase = util::fopen($var::NMZ{'_p'});
    my $fh_phraseindex;
    if ($fh_phrase) {
	$fh_phraseindex = util::efopen($var::NMZ{'_pi'});
	$opened = 1;
    }
	
    my $ptr = 0;
    for (my $i = 0; $i < 65536; $i++) {

	my $baserecord = "";
	my $baseleng = 0;

	if ($opened) {
	    my $tmp = 0;
	    read($fh_phraseindex, $tmp, $var::INTSIZE);
	    $tmp = unpack("N", $tmp);
	    if ($tmp != 0xffffffff) { # 0xffffffff
		$baseleng = readw($fh_phrase);
		read($fh_phrase, $baserecord, $baseleng);
	    }
	}
	if (defined($PhraseHash{$i})) {
	    if ($baserecord eq "") {
		print $fh_tmp_pi pack("N", $ptr);
		my $record = $PhraseHash{$i};
		my $n2 = length($record);
		my $data = pack("w", $n2) . $record;
		print $fh_tmp_p $data;
		$ptr += length($data);
	    } else {
		print $fh_tmp_pi pack("N", $ptr);
		my $record = $PhraseHash{$i};
		my $last_docid = get_last_docid($baserecord, 1);
		$record = adjust_first_docid($record, $last_docid);
		my $n2 = length($record) + $baseleng;
		my $data = pack("w", $n2) .  $baserecord . $record;
		print $fh_tmp_p $data;
		$ptr += length($data);
	    }
	} else {
	    if ($baserecord eq "") {
		# if $baserecord has no data, set to 0xffffffff
		print $fh_tmp_pi pack("N", 0xffffffff);
	    } else {
		print $fh_tmp_pi pack("N", $ptr);
		my $data = pack("w", $baseleng) . $baserecord;
		print $fh_tmp_p $data;
		$ptr += length($data);
	    }
	}
    }
    %PhraseHash = ();
    %PhraseHashLast = ();
}

# Dr. Knuth's  ``hash'' from (UNIX MAGAZINE May 1998)
sub hash ($) {
    my ($word) = @_;

    my $hash = 0;
    for (my $i = 0; $word ne ""; $i++) {
	$hash ^= $Seed[$i & 0x03][ord($word)];
        $word = substr $word, 1;
	# $word =~ s/^.//;  is slower
    }
    return $hash & 65535;
}

# Count frequencies of words.
sub count_words ($$$$) {
    my ($file_count, $file_base, $contref, $kanji) = @_;
    my (@tmp);

    # Normalize into small letter.
    $$contref =~ tr/A-Z/a-z/;

    # Do wakatigaki if necessary.
    if (util::islang("ja")) {
	wakati::wakatize_japanese($contref) if $kanji;
    }

    # Remove all symbols when -K option is specified.
    $$contref =~ tr/\xa1-\xfea-z0-9/   /c if $var::Opt{'nosymbol'};

    my $part1 = "";
    my $part2 = "";
    if ($$contref =~ /\x7f/) {
	$part1 = substr $$contref, 0, index($$contref, "\x7f");
	$part2 = substr $$contref, index($$contref, "\x7f");
#	$part1 = $PREMATCH;  # $& and friends are not efficient
#	$part2 = $MATCH . $POSTMATCH;
    } else {
	$part1 = $$contref;
	$part2 = "";
    }

    # do scoring
    my %word_count = ();
    $part2 =~ s!\x7f *(\d+) *\x7f([^\x7f]*)\x7f */ *\d+ *\x7f!
	wordcount_sub($2, $1, \%word_count)!ge;
    wordcount_sub($part1, 1, \%word_count);

    # Add them to whole index
    my $docid = $file_count + $file_base;
    for my $word (keys(%word_count)) {
	next if ($word eq "" || length($word) > $conf::WORD_LENG_MAX);
	$KeyIndexLast{$word} = 0 unless defined $KeyIndexLast{$word};
	$KeyIndex{$word} .= pack("w2", 
				 $docid - $KeyIndexLast{$word}, 
				 $word_count{$word});
	$KeyIndexLast{$word} = $docid;
    }
}

# count words and do score weighting
# count words and do score weighting
sub wordcount_sub ($$\%) {
    my ($text, $weight, $word_count) = @_;

    # Count frequencies of words in a current document.
    # Handle symbols as follows.
    #
    # tcp/ip      ->  tcp/ip,     tcp,      ip
    # (tcp/ip)    ->  (tcp/ip),   tcp/ip,   tcp, ip
    # ((tcpi/ip)) ->  ((tcp/ip)), (tcp/ip), tcp
    #
    # Don't do processing for nested symbols.
    # NOTE: When -K is specified, all symbols are already removed.

    my @words = split /\s+/, $text;
    for my $word (@words) {
	next if $word eq "";
	if ($var::Opt{'noedgesymbol'}) {
	    # remove symbols at both ends
	    $word =~ s/^[^\xa1-\xfea-z_0-9]*(.*?)[^\xa1-\xfea-z_0-9]*$/$1/g;
	}
	$word_count->{$word} = 0 unless defined($word_count->{$word});
	$word_count->{$word} += $weight;
	unless ($var::Opt{'nosymbol'}) {
	    if ($word =~ /^[^\xa1-\xfea-z_0-9](.+)[^\xa1-\xfea-z_0-9]$/) {
		$word_count->{$1} = 0 unless defined($word_count->{$1});
		$word_count->{$1} += $weight;
		next unless $1 =~ /[^\xa1-\xfea-z_0-9]/;
	    } elsif ($word =~ /^[^\xa1-\xfea-z_0-9](.+)/) {
		$word_count->{$1} = 0 unless defined($word_count->{$1});
		$word_count->{$1} += $weight;
		next unless $1 =~ /[^\xa1-\xfea-z_0-9]/;
	    } elsif ($word =~ /(.+)[^\xa1-\xfea-z_0-9]$/) {
		$word_count->{$1} = 0 unless defined($word_count->{$1});
		$word_count->{$1} += $weight;
		next unless $1 =~ /[^\xa1-\xfea-z_0-9]/;
	    }
	    my @words_ = split(/[^\xa1-\xfea-z_0-9]+/, $word)
		if $word =~ /[^\xa1-\xfea-z_0-9]/;
	    for my $tmp (@words_) {
		next if $tmp eq "";
		$word_count->{$tmp} = 0 unless defined($word_count->{$tmp});
		$word_count->{$tmp} += $weight;
	    }
	    @words_ = ();
	}
    }
    return "";
}

# Construct NMZ.i and NMZ.ii file. this processing is rather complex.
sub write_index () {
    my $key_count = write_index_sub();
    util::Rename($var::NMZ{'__i'}, $var::NMZ{'_i'});
    util::Rename($var::NMZ{'__w'}, $var::NMZ{'_w'});

    return $key_count;
}

# readw: read one pack 'w' word.
# This code was contributed by <furukawa@tcp-ip.or.jp>.
sub readw ($) {
    my $fh = shift;
    my $ret = '';
    my $c;
    
    while (read($fh, $c, 1)){
	$ret .= $c;
	last unless 0x80 & ord $c;
    }
    return unpack('w', $ret);
}

sub get_last_docid ($$) {
    my ($record, $step) = @_;
    my (@data) = unpack 'w*', $record;

    my $sum = 0;
    for (my $i = 0; $i < @data; $i += $step) {
	$sum += $data[$i];
    }
    my $leng = @data / $step;
    return $sum;
}

sub adjust_first_docid ($$) {
    my ($record, $last_docid) = @_;
    my (@data) = unpack 'w*', $record;

    my $val = $data[0];
    $data[0] = $data[0] - $last_docid;
    my $adjusted = $val - $last_docid;
    $record = pack 'w*', @data;
    return $record;
}

sub write_index_sub () {
    my @words = sort keys(%KeyIndex);
    return 0 if $#words == -1;

    my $cnt = 0;
    my $ptr_i = 0;
    my $ptr_w = 0;
    my $key_count = 0;
    my $baserecord = "";

    util::dprint("doing write_index() processing.\n");
    my $fh_tmp_i  = util::efopen(">$var::NMZ{'__i'}");
    my $fh_tmp_w  = util::efopen(">$var::NMZ{'__w'}");
    my $fh_i      = util::fopen($var::NMZ{'_i'});
    my $fh_ii     = util::efopen(">$var::NMZ{'_ii'}");
    my $fh_w      = util::fopen($var::NMZ{'_w'});
    my $fh_wi = util::efopen(">$var::NMZ{'_wi'}");

    if ($fh_w) {
      FOO:
	while (defined(my $line = <$fh_w>)) {
	    chop $line;
	    my $current_word = $line;

	    my $baseleng = readw($fh_i);
	    read($fh_i, $baserecord, $baseleng);

 	    for (; $cnt < @words; $cnt++) {
		last unless $words[$cnt] le $current_word;
		my $record = $KeyIndex{$words[$cnt]};
		my $leng = length($record);

		if ($current_word eq $words[$cnt]) {
		    my $last_docid = get_last_docid($baserecord, 2);
		    $record = adjust_first_docid($record, $last_docid);
		    $leng = length($record);  # re-measure
		    my $tmp = pack("w", $leng + $baseleng);

		    my $data_i = "$tmp$baserecord$record";
		    my $data_w = "$current_word\n";
		    print $fh_tmp_i $data_i;
		    print $fh_tmp_w $data_w;
		    print $fh_ii pack("N", $ptr_i);
		    print $fh_wi pack("N", $ptr_w);
		    $ptr_i += length($data_i);
		    $ptr_w += length($data_w);
		    $key_count++;

		    $cnt++;
		    next FOO;
		} else {
		    my $tmp = pack("w", $leng);
		    my $data_i = "$tmp$record";
		    my $data_w = "$words[$cnt]\n";
		    print $fh_tmp_i $data_i;
		    print $fh_tmp_w $data_w;
		    print $fh_ii pack("N", $ptr_i);
		    print $fh_wi pack("N", $ptr_w);
		    $ptr_i += length($data_i);
		    $ptr_w += length($data_w);
		    $key_count++;
		}
	    }
	    my $tmp  = pack("w", $baseleng);
	    my $data_i = "$tmp$baserecord";
	    my $data_w = "$current_word\n";
	    print $fh_tmp_i $data_i;
	    print $fh_tmp_w $data_w;
	    print $fh_ii pack("N", $ptr_i);
	    print $fh_wi pack("N", $ptr_w);
	    $ptr_i += length($data_i);
	    $ptr_w += length($data_w);
	    $key_count++;
	}
    }
    while ($cnt < @words) {
	my $leng = length($KeyIndex{$words[$cnt]});
	my $tmp = pack("w", $leng);
	my $record = $KeyIndex{$words[$cnt]};

	my $data_i = "$tmp$record";
	my $data_w = "$words[$cnt]\n";
	print $fh_tmp_i $data_i;
	print $fh_tmp_w $data_w;
	print $fh_ii pack("N", $ptr_i);
	print $fh_wi pack("N", $ptr_w);
	$ptr_i += length($data_i);
	$ptr_w += length($data_w);
	$key_count++;
	$cnt++;
    }
    %KeyIndex = ();
    %KeyIndexLast = ();

    return $key_count;
}

sub setup_magic () {
    $Magic->addSpecials("text/plain; x-type=rfc",
			"^Network Working Group",
			"^Request [fF]or Comments",
			"^Obsoletes:",
			"^Category:",
			"^Updates:");
    $Magic->addFileExts('^rfc\d+\.txt$', 'text/plain; x-type=rfc');
    $Magic->addFileExts('^draft-(\w*-)+-\d+\.txt$', 'text/plain; x-type=internet-draft');
    $Magic->addFileExts('^fyi\d+\.txt$' => 'text/plain; x-type=fyi');
    $Magic->addMagicEntry('0	string		\<!--\ MHonArc		text/html; x-type=mhonarc');
}

# decide file type from diffrent type ditection
sub decide_type ($$) {
    my ($name, $cont) = @_;
    return $name if (!defined $cont || $name eq $cont);

    if ($cont =~ /^text/ && $name =~ /.*;.*x-type=(rfc|internet-draft|fyi)/) {
	return $name;
    }

    return $cont;
}

# for avoiding "used only once: possible typo at ..." warnings

muda($conf::ON_MEMORY_MAX,
     $conf::WORD_LENG_MAX, $conf::TEXT_SIZE_MAX,
     $conf::DENY_REGEX, $var::INTSIZE,
     $conf::CHASEN_MORPH, $conf::CHASEN,
     $conf::KAKASI, $var::Opt{'okurigana'},
     $var::Opt{'hiragana'}, $conf::ROBOTS_EXCLUDE_URLS, $conf::DEFAULT_FILE,
     $conf::HTML_SUFFIX, $usage::USAGE_EN, $usage::USAGE_MINI, 
     $var::Opt{'noheadabst'}, 
     $var::Opt{'noencodeurl'}, $var::Opt{'htaccessexclude'}, 
     $var::RECURSIVE_ACTIONS, $conf::ROBOTS_EXCLUDE_URIS, 
     $conf::ROBOTS_EXCLUDE_URLS, $conf::META_TAGS);


sub muda(@) {}

