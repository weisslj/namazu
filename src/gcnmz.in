#! @PERL@ -w
# gcnmz.pl - by furukawa@tcp-ip.or.jp

&gcnmz('.');

sub gcnmz{
    my $dir = shift;
    my %table = ();
    my $nmzi = new nmzdb($dir);
    my $nmzo = new nmzdb($dir, 'w');
    {
        my $file_num = 0;
        my %list;
        $nmzi->open_flist;
        $nmzo->open_flist;
        while (defined $nmzi->{'flist'}->read(\%list)){
            if ($list{'t'} != -1){
                $table{$file_num} = $nmzo->{'flist'}->{'index'};
                $nmzo->{'flist'}->write(\%list);
            }
            ++$file_num;
        }
    }

    {
        my $word;
        my %list_i;

        $nmzi->open_word;
        $nmzo->open_word;
        while (defined $nmzi->{'word'}->read(\$word, \%list_i)){
            my %list_o;
            for my $key (keys %list_i){
                if (defined $table{$key}){
                    $list_o{$table{$key}} = $list_i{$key};
                }
            }
            $nmzo->{'word'}->write($word, \%list_o);
        }
    }
    {
        $nmzi->open_phrase;
        $nmzo->open_phrase;
        for (my $x = 0; $x < 0x10000; $x++){
            my @list_i;
            my @list_o;
            $nmzi->{'phrase'}->read(\@list_i);
            for my $key (@list_i){
                if (defined $table{$key}){
                    push(@list_o, $table{$key});
                }
            }
            $nmzo->{'phrase'}->write(\@list_o);
        }
    }

    $nmzo->write_status($nmzi);
    $nmzo->replace_db(0);
    if (my $log = $nmzo->log_open("[Garbage Collection]")){
        $log->printf("Collected Entry: %d files\n", $nmzi->{'flist'}->{'count'} - $nmzo->{'flist'}->{'count'});
        $log->printf("Total Files: %d files\n", $nmzo->{'flist'}->{'count'});
        $log->printf("Total Keywords: %d files\n", $nmzo->{'word'}->{'count'});
        $nmzo->log_close;
    }
}



use strict;
use IO::File;
use DirHandle;

package nmzlib;

sub open_db{
    my $par = shift;
    my $ext = shift;
    my $path = $par->{'dir'} . "/NMZ.$ext";
    my $fh;
    if ($par->{'mode'} eq 'w'){
        $fh = new IO::File "$path.$$.tmp", $par->{'mode'};
    }else{
        $fh = new IO::File $path;
    }
    $par->{'dblist'}->{$path} = $fh, binmode $fh if defined $fh;
    return $fh;
}

sub readw{
    my $fh = shift;
    my $ret = '';
    my $c;

    while (read($fh, $c, 1)){
        $ret .= $c;
        last unless 0x80 & ord $c;
    }
    unpack('w', $ret);
}


package nmzflist;
sub new{
    my $class = shift;
    my $self = {};
    my $par = shift;
    bless $self, $class;

    $self->{'t'} = &nmzlib::open_db($par, 't');
    $self->{'r'} = &nmzlib::open_db($par, 'r');

    my $dh = new DirHandle($par->{'dir'});
    while (defined(my $ent = $dh->read)){
        if (my ($ext, $ndx) = ($ent =~ /^NMZ\.field\.((?:[sn]\.)?[^\.]+)(\.i)?$/)){
            unless (defined $ndx){
                $self->{"field"}->{$ext} = &nmzlib::open_db($par, "field.$ext");
            }
            if ($par->{'mode'} eq 'w' xor defined $ndx){
                $self->{"field.i"}->{$ext} = &nmzlib::open_db($par, "field.$ext.i");
            }
        }
    }
    $dh->close;
    $self->{'index'} = 0;
    $self->{'count'} = 0;
    return $self;
}

sub read{
    my $self = shift;
    my $list = shift;
    %$list = ();

    my $fh = $self->{'t'};
    $fh->read(my $pindex, length pack('N', 0));
    $list->{'t'} = ($pindex eq pack('N', -1))? -1: unpack('N', $pindex);

    $fh = $self->{'r'};
    $list->{'r'} = $fh->getline;
    $list->{'r'} = $fh->getline while (defined($list->{'r'}) && $list->{'r'} =~ /^[\#\r\n]/);

    if (defined $list->{'r'}){
        chomp $list->{'r'};
        my $field = $self->{'field'};
        for my $key (keys %$field){
            $fh = $field->{$key};
            my $line = $fh->getline;
            $line = '' unless defined $line;
            chomp $line;
            $list->{'field'}->{$key} = $line;
        }
        ++$self->{'index'};
        $self->{'count'} = $self->{'index'} if $self->{'index'} > $self->{'count'}
    }
    return $list->{'r'}
}

sub write{
    my $self = shift;
    my $list = shift;

    my $fh = $self->{'t'};
    $fh->print(pack('N', $list->{'t'}));

    $fh = $self->{'r'};
    $fh->print($list->{'r'} . "\n");

    my $field = $self->{'field'};
    my $fieldi = $self->{'field.i'};
    for my $key (keys %$field){
        if (defined($fh = $field->{$key})){
            if (defined(my $fhi = $fieldi->{$key})){
                print $fhi pack('N', $fh->tell);
            }
            $fh->print($list->{'field'}->{$key} . "\n");
        }
    }
    ++$self->{'index'};
    ++$self->{'count'};
}


package nmzword;
sub new{
    my $class = shift;
    my $par = shift;
    my $self = {};
    bless $self, $class;

    $self->{'i'} = &nmzlib::open_db($par, 'i');
    $self->{'ii'} = &nmzlib::open_db($par, 'ii');
    $self->{'w'} = &nmzlib::open_db($par, 'w');
    $self->{'wi'} = &nmzlib::open_db($par, 'wi');
    $self->{'index'} = 0;
    $self->{'count'} = 0;
    return $self;
}

sub read{
    my $self = shift;
    my $word = shift;
    my $list = shift;
    %$list = ();

    my $fh_w = $self->{'w'};
    return unless defined($$word = <$fh_w>);
    chomp $$word;

    my $fh_i = $self->{'i'};
    $fh_i->read(my $tmp, &nmzlib::readw($fh_i));

    my @tmp = unpack('w*', $tmp);
    my $key = shift @tmp;
    $list->{$key} = shift @tmp;
    $key += shift @tmp, $list->{$key} = shift @tmp while @tmp;

    ++$self->{'index'};
    $self->{'count'} = $self->{'index'} if $self->{'index'} > $self->{'count'};
    return $$word;
}

sub write{
    my $self = shift;
    my $word = shift;
    my $list = shift;

    if (length $word and scalar keys %$list){
        my $fh_i = $self->{'i'};
        my $fh_ii = $self->{'ii'};
        my $fh_w = $self->{'w'};
        my $fh_wi = $self->{'wi'};
        my @tmp = ();
        my $ndx = 0;

        print $fh_ii pack('N', $fh_i->tell);
        print $fh_wi pack('N', $fh_w->tell);
        print $fh_w "$word\n";
        for my $key (sort {$a <=> $b} keys %$list){
            push(@tmp, $key - $ndx);
            push(@tmp, $list->{$key});
            $ndx = $key;
        }
        my $tmp = pack('w*', @tmp);
        print $fh_i pack('w', length $tmp) . $tmp;
        ++$self->{'index'};
        ++$self->{'count'};
    }
}


package nmzphrase;
sub new{
    my $class = shift;
    my $par = shift;
    my $self = {};
    bless $self, $class;

    $self->{'p'} = &nmzlib::open_db($par, 'p');
    $self->{'pi'} = &nmzlib::open_db($par, 'pi');
    $self->{'index'} = 0;
    return $self;
}

sub read{
    my $self = shift;
    my $list = shift;

    my $fh_p = $self->{'p'};
    my $fh_pi = $self->{'pi'};

    $fh_pi->read(my $pindex, length pack('N', 0));
    if ($pindex ne pack('N', -1)){
        $fh_p->read(my $tmp, &nmzlib::readw($fh_p));
        my @tmp = unpack('w*', $tmp);
        push(@$list, my $key = shift @tmp);
        push(@$list, $key += shift @tmp) while @tmp;
    }else{
        @$list = ();
    }
    ++$self->{'index'};
    return scalar @$list;
}

sub write{
    my $self = shift;
    my $list = shift;

    my $fh_p = $self->{'p'};
    my $fh_pi = $self->{'pi'};
    my @tmp = ();
    my $ndx = 0;

    if (scalar @$list){
        print $fh_pi pack('N', $fh_p->tell);

        for my $key (@$list){
            push(@tmp, $key - $ndx);
            $ndx = $key;
        }
        my $tmp = pack('w*', @tmp);
        print $fh_p pack('w', length $tmp) . $tmp;
    }else{
        print $fh_pi pack('N', -1);
    }
    ++$self->{'index'};
}


package nmzdb;
sub new{
    my $class = shift;
    my $self = {};
    bless $self, $class;

    $self->{'dir'} = '.';
    $self->{'dir'} = shift if @_;

    $self->{'mode'} = 'r';
    $self->{'mode'} = shift if @_;
    return $self;
}

sub open_flist{
    my $self = shift;
    $self->{'flist'} = new nmzflist($self);
    return $self->{'flist'};
}

sub open_word{
    my $self = shift;
    $self->{'word'} = new nmzword($self);
    return $self->{'word'};
}

sub open_phrase{
    my $self = shift;
    return $self->{'phrase'} = new nmzphrase($self);
}

sub replace_db{
    my $self = shift;
    my $bak = @_? shift : 0;
    for my $path (keys %{$self->{'dblist'}}){
        $self->{'dblist'}->{$path}->close;
        rename $path, "$path.BAK" if $bak;
        rename "$path.$$.tmp", $path;
    }
}

sub write_status{
    my $self = shift;
    my $in = shift;
    my $key = $self->{'word'}->{'count'};
    my $file = $self->{'flist'}->{'count'};
    if ($self->{'mode'} eq 'w'){
        my $fi = &nmzlib::open_db($in, 'status');
        my $fo = &nmzlib::open_db($self, 'status');
        while (defined(my $line = $fi->getline)){
            $line = "file $file\n" if $line =~ /^file /;
            $line = "key $key\n" if $line =~ /^key /;
            $fo->print($line);
        }
        my $dh = new DirHandle($in->{'dir'});
        while (defined(my $ent = $dh->read)){
            if ($ent =~ /^NMZ\.(head\.[^\.]+)$/){
                $fi = &nmzlib::open_db($in, $1);
                $fo = &nmzlib::open_db($self, $1);

                while (defined(my $line = $fi->getline)){
                    $line =~ s/(\<\!-- FILE --\>).*?\1/$1 $file $1/;
                    $line =~ s/(\<\!-- KEY --\>).*?\1/$1 $key $1/;
                    $fo->print($line);
                }
            }
        }
        undef $dh;
    }
}

sub log_open{
    my $self = shift;
    my $tag = shift;
    my $path = $self->{'dir'} . "/NMZ.log";
    my $fh = new IO::File ">>$path";
    if (defined $fh){
        $fh->print("$tag\n") if defined $tag;
        $fh->print("Date: " . localtime($^T) . "\n");
    }
    return $self->{'log'} = $fh;
}

sub log_close{
    my $self = shift;
    if (defined $self->{'log'}){
        $self->{'log'}->print("Perl: $]\n");
        $self->{'log'}->print("System: $^O\n");
        $self->{'log'}->printf("Time: %d sec.\n\n", time - $^T);
        $self->{'log'}->close;
    }
}
