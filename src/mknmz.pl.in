#! @PERL@ -w
# -*- CPerl -*-
# mknmz - indexer of Namazu
# $Id: mknmz.pl.in,v 1.38 1999-08-30 01:22:03 satoru Exp $
#
# Copyright (C) 1997-1999 Satoru Takabayashi  All rights reserved.
#     This is free software with ABSOLUTELY NO WARRANTY.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either versions 2, or (at your option)
#  any later version.
# 
#  This program is distributed in the hope that it will be useful
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
#  02111-1307, USA
#
#  This file must be encoded in EUC-JP encoding
#

package namazu;
require 5.004;
use Cwd;
use IO::File;
use Time::Local;
use File::MMagic;
use strict;  # be strict since v1.2.0
use Getopt::Long;

use vars qw($SYSTEM);
$SYSTEM = $^O;

my $CCS = "euc";
my $CONFDIR  = "%CONFDIR%";      # directory where mknmz.conf are in.
my $LIBDIR  = "%LIBDIR%";      # directory where library etc. are in.
my $FILTERDIR  = "%FILTERDIR%";      # directory where filters are in.
my $TEMPLATEDIR  = "%TEMPLATEDIR%";      # directory where templates are in.
my $TARGET_DIR = "";

my $DeletedFilesCount = 0;
my $UpdatedFilesCount = 0;
my $APPENDMODE = 0;
my %PhraseHash = ();
my %PhraseHashLast = ();
my %KeyIndex = ();
my %KeyIndexLast = ();
my %CheckPoint = ("on" => undef, "continue" => undef);
my $TestMode = @TEST_MODE@;

STDOUT->autoflush(1);
main();
sub main () {
    my $start_time = time;

    init();
    load_modules();
    read_config();
    my $file_base = prep();

    my $swap = 1;
    my $file_count = 0;
    my $total_files_size = 0;
    my $key_count = 0;
    my $checkpoint = 0;
    my $flist_ptr = 0;
    my $processed_files_size = 0;

    # Restore variables
    eval util::readfile($var::File{'CHECKPOINT_'}) if $CheckPoint{'continue'};

    {
	my $fh_errorsfile = util::efopen(">>$var::File{'ERRORSFILE'}");
	my $fh_flist = util::efopen($var::File{'FLIST_'});
	my %field_indices = ();
	get_field_index_base(\%field_indices);

	if ($CheckPoint{'continue'}) {
	    seek($fh_flist, $flist_ptr, 0);
	}

	# Process target files one by one
	while (<$fh_flist>) {
	    $flist_ptr += length;
	    my $cfile = $_;
	    chomp $cfile;
	    my $cfile_size = namazu_core($cfile, $file_count, $file_base, 
				 \%field_indices, $fh_errorsfile);
	    next unless $cfile_size;
	    put_registry($cfile);

	    $total_files_size     += $cfile_size;
	    $processed_files_size += $cfile_size;
	    $file_count++;
	    if ($processed_files_size > $conf::ON_MEMORY_MAX) {
		if (%KeyIndex) {
	    $key_count = write_index();
		    write_phrase_hash()
			unless $var::Opt{NoPhraseIndex};
		}
		$processed_files_size = 0;
		$checkpoint = 1, last if $CheckPoint{'on'} && defined(<$fh_flist>);
	    }
	}
    }
    # This should be out of above blocks because of file handler closing.
    re_exec($flist_ptr, $file_count, $file_base, 
	    $start_time, $total_files_size) if $checkpoint;

    if (%KeyIndex) {
	$key_count = write_index();
	write_phrase_hash() unless $var::Opt{NoPhraseIndex};
    }

    $key_count = get_total_keys() unless $key_count;
    do_remain_job($total_files_size, $file_count, $key_count, 
		   $start_time);
    exit 0;
}

sub read_config() {
    my @cand = ("$ENV{HOME}/.mknmzrc", 
		"$CONFDIR/mknmz.conf");
    my $conf2 = cwd() . "/../conf/mknmz.conf-dist";  # relative path from cwd
    push @cand, $conf2 if $TestMode;

    for my $conf (@cand) {
	if (-e $conf) {
	    print STDERR "\@\@ conf: $conf\n" if $TestMode;
	    require $conf;
	    return;
	}
    }
    die "No config file is available.\n";
}

sub re_exec($$$$) {
    my ($flist_ptr, $file_count, $file_base, $start_time, $total_files_size) = @_;

    # store variables
    {
	my $fh_checkpoint = util::efopen(">$var::File{'CHECKPOINT_'}");

	print $fh_checkpoint <<EOM;
	\$DeletedFilesCount = $DeletedFilesCount;
	\$UpdatedFilesCount = $UpdatedFilesCount;
	\$APPENDMODE = $APPENDMODE;
	\$flist_ptr = $flist_ptr;
	\$file_count = $file_count;
	\$file_base = $file_base;
	\$start_time = $start_time;
	\$total_files_size = $total_files_size;
	\$\$ = $$;
EOM
    }

    @ARGV = ("-S", @ARGV) ;
    print "Checkpoint reached: re-exec mknmz...\n" unless $var::Opt{Quiet};
    util::dprint(join ' ', ("::::", @ARGV, "\n"));
    exec ($0, @ARGV) ;
}

sub put_registry ($) {
    my ($filename) = @_;
    my $fh_registry = util::efopen(">>$var::File{'REGISTRY_'}");
    print $fh_registry $filename, "\n";
}


# Initialization
#   $CCS: Character Coding System 'euc' or 'sjis'
sub init () {
    $SYSTEM = $^O;
    if (($SYSTEM eq "MSWin32") || ($SYSTEM eq "os2")) {
	$CCS = "sjis";
	if ($LIBDIR !~ /^[A-Z]:/i && $0 =~ m#^([A-Z]:)(/|\\)#i) {
	    $LIBDIR = $1 . $LIBDIR ;
	}
    } else {
	$CCS = "euc";
    }

    $SIG{INT}  = sub {
	warn "SIGINT caught! removing tmporary files...\n";
	remove_tmpfiles();
	remove_lockfile($var::File{LOCKFILE2});

	my $errsize = -s $var::File{ERRORSFILE};
	unlink $var::File{ERRORSFILE} if $errsize == 0;
	warn "exit(2)\n";
    
	exit 2;
    };
}

sub load_modules () {
    my $libdir2 = cwd() . "/../lib";        # relative path from cwd
    unshift @INC, $LIBDIR;
    unshift @INC, $libdir2 if $TestMode;

    my $filterdir2 = cwd() . "/../filter";  # relative path from cwd
    unshift @INC, $FILTERDIR;
    unshift @INC, $filterdir2 if $TestMode;

    require "usage.pl";
    require "seed.pl";
    require "codeconv.pl";
    require "find.pl";
    require "util.pl";
    require "wakati.pl";

    # Check filter modules
    my @filters = ();
    @filters = glob "$filterdir2/*.pl" if $TestMode;
    @filters = glob "$FILTERDIR/*.pl" if @filters == 0;

    for my $filter (@filters) {
	$filter =~ m!(\w+)\.pl$!;
	my $module = $1;
	require "$module.pl";
	my (@mtypes, $status, $recursive);
	eval "\@mtypes =    ${module}::mediatype();";
	eval "\$status =    ${module}::status();";
	eval "\$recursive = ${module}::recursive();";
	for my $mt (@mtypes) {
	    $conf::Supported{$mt} = $status;
	    $var::REQUIRE_ACTIONS{$mt} = $module;
	    $var::RECURSIVE_ACTIONS{$mt} = $recursive if ($recursive)
	}
	print STDERR "\@\@ loaded: $module.pl [@mtypes]\n" 
	    if $TestMode;
    }
}

# Core routine
sub namazu_core ($$$) {
    my ($cfile, $file_count, $file_base, $field_indices, 
	$fh_errorsfile) = @_;

    my $headings = "";
    my $content = "";
    my $weighted_str = "";
    my %fields;

    # temporary
    my $title = "";

    my $uri = generate_uri($cfile);  # Make a URI from a file name
    my ($cfile_size, $kanji, $mtype) = 
	load_document(\$cfile, \$title, \$content, \$weighted_str,
		      \$headings, \%fields);

    # Do checking
    my $err = check_file($cfile, \$content, $cfile_size, $mtype);
    if ($err) {
	print $file_count + $file_base . " $uri $err\n" unless $var::Opt{Quiet};
	print $fh_errorsfile "$cfile $err\n"; 
	return 0;  # return with 0 if error
    }
    if ($var::Opt{RobotExclude}) {
	if ($uri =~ m/$conf::ROBOTS_EXCLUDE_URIS/io) {
	    $err = "is excluded because of /robots.txt.\n";
	    print $file_count + $file_base . " $uri $err\n";
	    print $fh_errorsfile "$cfile $err\n"; 
	    return 0;  # return with 0 if error
	} elsif ($cfile =~ /\.($conf::HTML_SUFFIX)$/io &&
		 $content =~ /META\s+NAME\s*=\s*([\'\"]?)ROBOTS\1\s+[^>]*
		 CONTENT\s*=\s*([\'\"]?).*?(NOINDEX|NONE).*?\2[^>]*>/ix)  #"
	{
	    $err = "is excluded because of <META> element.";
	    print $file_count + $file_base . " $uri $err\n" unless $var::Opt{Quiet};
	    print $fh_errorsfile "$cfile $err\n"; 
	    return 0;  # return with 0 if error
	}
    }
    # Output processing file name as URI
    print $file_count + $file_base . 
	" $uri :: $mtype\n" unless $var::Opt{Quiet};

    make_field_index(\%fields, $cfile, $uri, \$headings, \$content);
    put_field_index(\%fields, $field_indices) unless $var::Opt{NoFieldIndex};

    put_dateindex($cfile) unless $var::Opt{NoDateIndex};
    $content .= $weighted_str;   # add weight info
    count_words($file_count, $file_base, \$content, $kanji);
    make_phrase_hash($file_count, $file_base, \$content)
	unless $var::Opt{NoPhraseIndex};

    return $cfile_size;
}

# make a URI from a file name
sub generate_uri ($) {
    my ($file) = @_;
    return undef unless defined $file;

    my $uri = $file;
    # remove a file name if omittable
    if ($var::PREFIX && $TARGET_DIR) {
	$uri =~ s!(.*)/($conf::DEFAULT_FILE)$!$1/!o; 
	$uri =~ s!$TARGET_DIR/!$var::PREFIX!o;
    }

    if (($SYSTEM eq "MSWin32") || ($SYSTEM eq "os2")) {
	# convert \ to / with consideration for Shift_JIS Kanji code
#	$uri =~ s!([\x81-\x9f\xe0-\xef][\x40-\x7e\x80-\xfc]|[\x01-\x7f])!
#	    $1 eq "\\" ? "/" : $1!gex;
	$uri =~ s#^([A-Z]):#/$1|#i; # converting a drive part like: /C|
    }

    unless ($var::Opt{NoEncodeURI}) {
	# Escape unsafe characters (not strict)
	$uri =~ s/\%/%25/g;  # Convert original '%' into '%25' v1.1.1.2
	$uri =~ s/([^a-zA-Z0-9~\-\_\.\/\:\%])/
	    sprintf("%%%02X",ord($1))/ge;
	if (($SYSTEM eq "MSWin32") || ($SYSTEM eq "os2")) {
	    # restore '|' for drive letter rule of Win32, OS/2
	    $uri =~ s!^/([A-Z])%7C!/$1|!i;
	}
    }
    return $uri;
}


sub get_field_index_base (\%) {
    my ($field_indices) = @_;

    my @keys = split('\|', $conf::SEARCH_FIELD);
    for my $key (@keys) {
	$key = lc($key);
	my $fname    = "$var::File{'FIELDINFO'}.$key";
	my $tmp_fname = "$var::File{'FIELDINFO'}.$key.$$";
	my $size = 0;
	$size = -s $fname if -e $fname;
	$size += -s $tmp_fname if -e $tmp_fname;
	$field_indices->{$key} = $size;
    }
}

sub make_field_index (\%$$\$\$) {
    my ($fields, $cfile, $uri, $headings, $content) = @_;

    unless (defined($fields->{'date'})) {
	my $mtime = (stat($cfile))[9];
	my $date = util::rfc822time($mtime);
	$fields->{'date'} = $date;
    }
    unless (defined($fields->{'uri'})) {
	$fields->{'uri'} = $uri;
    }
    unless (defined($fields->{'size'})) {
	$fields->{'size'} = -s $cfile;
    }
    unless (defined($fields->{'summary'})) {
	$fields->{'summary'} = make_summary($content, $headings, $cfile);
    }
    unless (defined($fields->{'from'})) {
	$fields->{'from'} = "(unknown)";
    }
}

sub make_summary ($$$) {
    my ($content, $headings, $cfile) = @_;

    # pick up $conf::SUMMARY_LENGTH bytes string
    my $tmp = "";
    if ($$headings ne "") {
	$$headings =~ s/^\s+//;
	$$headings =~ s/\s+/ /g;
	$tmp = $$headings;
    } else {
	$tmp = "";
    }

    my $offset = 0;
    my $tmplen = 0;
    while (($tmplen = $conf::SUMMARY_LENGTH + 1 - length($tmp)) > 0
           && $offset < length($$content))
    {
        $tmp .= substr $$content, $offset, $tmplen;
        $offset += $tmplen;
        $tmp =~ s/(([\xa1-\xfe]).)/$2 eq "\xa8" ? '': $1/ge;
        $tmp =~ s/([-=*\#])\1{2,}/$1$1/g;
    }

    my $summary = substr $tmp, 0, $conf::SUMMARY_LENGTH;
    my $kanji = $summary =~ tr/\xa1-\xfe/\xa1-\xfe/;
    $summary .= substr($tmp, $conf::SUMMARY_LENGTH, 1) if $kanji %2;

    $summary =~ s/^\s+//;
    $summary =~ s/\s+/ /g;   # normalize white spaces

    return $summary;
}


# output the field infomation into NMZ.fields.* files
sub put_field_index (\%$) {
    my ($fields, $field_indices) = @_;

    my $aliases_regex = 
	join('|', sort {length($b) <=> length($a)} keys %conf::FIELD_ALIASES);

    for my $field (keys %{$fields}) {
	if ($field =~ /^($aliases_regex)$/o) {
	    unless (defined($fields->{$conf::FIELD_ALIASES{$field}})) {
		$fields->{$conf::FIELD_ALIASES{$field}} = $fields->{$field};
	    }
	    undef $fields->{$field};
	}
    }

    my @keys = split('\|', $conf::SEARCH_FIELD);
    for my $key (@keys) {
	$key = lc($key);
	my $fname    = "$var::File{'FIELDINFO'}.$key.$$";
	my $fh_field = util::efopen(">>$fname");
	my $output = "";
	if (defined($fields->{$key})) {
	    $fields->{$key} =~ s/\s+/ /g;
	    $fields->{$key} =~ s/\s+$//;
	    $fields->{$key} =~ s/^\s+//;
	    $output = $fields->{$key} . "\n";
	    if (length($output) >= 1024) {
		$output = substr $output, 0, 1023;
	    }
	} else {
	    $output = "\n";
	}
	print $fh_field $output;

	# put index of field index
	{
	    my $fname        = "$var::File{'FIELDINFO'}.$key.i.$$";
	    my $fh_field_idx = util::efopen(">>$fname");
	    print $fh_field_idx pack("N", $field_indices->{$key});
	    $field_indices->{$key} += length $output;
	}
    }
}


# put the date infomation into NMZ.t file
sub put_dateindex ($) {
    my ($cfile) = @_;
    my $mtime = (stat($cfile))[9];

    my $fh_dataindex = util::efopen(">>$var::File{'DATEINDEX_'}");
    print $fh_dataindex pack("N", $mtime);
}


# load a document file
sub load_document ($$$$$\%) {
    my ($orig_cfile, $title, $content, $weighted_str, $headings, $fields)
      = @_;
    my $cfile = $$orig_cfile;

    return (0, 0, 0) unless (-f $cfile && -r $cfile);

    # for handling a filename which contains Shift_JIS code
    my $shelter_cfile = "";
    if ($SYSTEM eq "MSWin32" 
	&& $cfile =~ /[\x81-\x9f\xe0-\xef][\x40-\x7e\x80-\xfc]|[\x20\xa1-\xdf]/) 
    {
	$shelter_cfile = $cfile;
	$cfile = $var::File{'TMP_WAKATI'};
        util::cp($shelter_cfile,$cfile);
    }

    $$content = util::readfile($cfile);

    # filtering process
    my $mm = new File::MMagic;
    my $mtype;
    while (1) {
	unless(File::MMagic::check_binary($$content)) { # text file
	    codeconv::toeuc($content);
	}

	my $mtype_n = $mm->checktype_byfilename($cfile);
	my $mtype_c = $mm->checktype_contents($$content);
	$mtype = decide_type($mtype_n, $mtype_c);
	util::dprint("Detected type: $mtype\n");
	if (defined $var::REQUIRE_ACTIONS{$mtype}) {
	    util::vprint("Using $var::REQUIRE_ACTIONS{$mtype}.pl\n");
	    require $var::REQUIRE_ACTIONS{$mtype}.'.pl';
	    eval $var::REQUIRE_ACTIONS{$mtype} .
	      '::filter($orig_cfile, $content, $weighted_str, $headings, $fields);';
	    if ($@) {
		print STDERR "Faild to call $var::REQUIRE_ACTIONS{$mtype}\n$@\n";
		$mtype = "x-system/x-error; failed to call $var::REQUIRE_ACTIONS{$mtype}";
		last;
	    }
	    next if (defined $var::RECURSIVE_ACTIONS{$mtype});
	}
	last;
    }

    my $size = length($$content); # masure size at this time

    if ($SYSTEM eq "MSWin32" && $shelter_cfile ne "") {
	unlink $cfile;
	$cfile = $shelter_cfile;
    }

    $$content =~ s/[ \t]+/ /g;   # remain LFs v1.03
    $$content =~ s/\r\n/\n/g;    # remain LFs for ChaSen
    $$content =~ s/\r/\n/g;      # CR+LF or CR are into LF


    # Control characters be into space
    $$content =~ tr/\x00-\x09\x0b-\x1f\x7f\xff/    /;
    my $kanji = $$content =~ tr/\xa1-\xfe/\xa1-\xfe/;  # Kanji contained?

    return ($size, $kanji, $mtype);
}

sub prep () {
    my $file_base = 0;
    my $output_dir = "";
    my $target_dir = "";
    my @flist = ();

    ($output_dir, $target_dir, @flist) = parse_options();
    $TARGET_DIR = $target_dir;

    require_modules();
    change_dbnames($output_dir);
    check_present_index();

    # if Checkpoint mode, return
    return 0 if $CheckPoint{'continue'};

    @flist = find_target($target_dir) unless @flist;
    ($file_base, @flist) = append_index(@flist) 
	if -e $var::File{'REGISTRY'};
    unless (@flist) { # if @flist is empty
	print "No files to index.\n";
	exit 0;
    }
    set_lockfile($var::File{LOCKFILE2});
    save_flist(@flist);

    return $file_base;
}

sub find_target ($) {
    my ($target_dir) = @_;
    my @flist = ();

    html::parse_robots_txt() if ($var::Opt{RobotExclude});
    my $current_dir = cwd();
    chdir $target_dir || die "$target_dir: $!\n";
    find::findfiles(\@flist);
    chdir $current_dir;

    return @flist;
}

sub save_flist(@) {
    my @flist = @_;
    return if (@flist == 0);

    my $fh_flist = util::efopen(">$var::File{'FLIST_'}");
    print $fh_flist join("\n", @flist), "\n";
}

sub require_modules() {
    if ($conf::LANGUAGE eq "ja" && $conf::NKF =~ /^module_nkf/) {
	require NKF;
        util::dprint("code conversion: using NKF module\n");
	$var::USE_NKF_MODULE = 1;
    }
    if ($conf::LANGUAGE eq "ja" && $conf::WAKATI =~ /^module_kakasi/) {
	require Text::Kakasi;
        util::dprint("wakati: using Text::Kakasi module\n");
	my $res = Text::Kakasi::getopt_argv('kakasi', '-ieuc', '-oeuc', '-w');
    }
    if ($conf::LANGUAGE eq "ja" && $conf::WAKATI =~ /^module_chasen1/) {
	require Text::ChaSen1;
        util::dprint("wakati: using Text::ChaSen1 module\n");
	my @arg = ('-j', '-F', '%m ');
	@arg    = ('-j', '-F', '%m %H\\n') if $var::Opt{Morph};
	my $res = Text::ChaSen1::getopt_argv('chasen-perl', @arg);
    }
}

sub set_lockfile ($) {
    my ($file) = @_;

    # make a lock file
    if (-f $file) {
	print "$file found. Maybe this index is being updated by another process now.\nIf not, you can remove this file.\n";
	exit 1;
    } else {
	my $fh_lockfile = util::efopen(">$file");
	print $fh_lockfile "$$"; # save pid
    }
}

sub remove_lockfile ($) {
    my ($file) = @_;

    # remove lock file
    unlink $file if -e $file;
}

# check present index whether it is old type of not
sub check_present_index () {
    if (-f $var::File{'LITTLEENDIAN'} || -f $var::File{'BIGENDIAN'}) 
    {
	die "!!ERROR!!\nPresent index is old type. it's unsupported.\n";
    }
}

# remain
sub do_remain_job ($$$$) {
    my ($total_files_size, $file_count, $key_count, $start_time) = @_;

    if ($file_count == 0) {
	# No files are indexed
	if ($DeletedFilesCount > 0) {
	    update_dateindex();
	    update_registry($file_count);
	}
    } else {
	set_lockfile($var::File{LOCKFILE});
	write_body_msg();
	write_result_file();
	update_field_index();
	update_dateindex();
	update_registry($file_count);
	write_nmz_files();
	make_slog_file();
	remove_lockfile($var::File{LOCKFILE});
    }
    make_headfoot_pages($file_count, $key_count);
    put_log($total_files_size, $start_time, $file_count, $key_count);
    remove_lockfile($var::File{LOCKFILE2});
    remove_tmpfiles();
    unlink $var::File{'FLIST_'};
}

sub make_headfoot_pages($$) {
    my ($file_count, $key_count) = @_;

    make_headfoot("$var::File{'HEADERFILE'}.ja", $file_count, $key_count);
    make_headfoot("$var::File{'FOOTERFILE'}.ja", $file_count, $key_count);
    make_headfoot("$var::File{'HEADERFILE'}.en", $file_count, $key_count);
    make_headfoot("$var::File{'FOOTERFILE'}.en", $file_count, $key_count);
}

sub remove_tmpfiles() {
    $var::File{'INDEX_'} =~ m!^(.*/)!;
    unlink glob "${1}NMZ.*$$*";
}

# parse comannd line options
sub parse_options ()
{
    if (@ARGV == 0) {
	show_mini_usage();
	exit 1;
    }

    my $output_dir = "";
    my $target_dir = "";
    my $target_loaded = 0;
    my @flist = ();
    my @argv = @ARGV;

    my $opt_version = 0;
    my $opt_help = 0;
    my $opt_all = 0;
    my $opt_chasen = 0;
    my $opt_chasen_morph = 0;
    my $opt_kakasi = 0;
    my $opt_man = 0;
    my $opt_include = 0;
    my $opt_target_list = 0;
    my $opt_target_regex = 0;
    my $opt_checkpoint_sub = 0;
    
#    Getopt::Long::Configure('bundling');
    Getopt::Long::config('bundling');
    GetOptions('u|uuencode'          => \$var::Opt{Uuencode},
	       'h|rfc822'            => \$var::Opt{MailNews},
	       'H|no-hiragana'       => \$var::Opt{Hiragana},
	       'G|no-okurigana'      => \$var::Opt{Okurigana},
	       'E|no-edge-symbol'    => \$var::Opt{NoEdgeSymbol},
	       'K|no-symbol'         => \$var::Opt{NoSymbol},
	       'L|no-line-adjust'    => \$var::Opt{NoLineAd},
	       'M|no-mhonarc'        => \$var::Opt{NoMHonArc}, 
	       'U|no-encode-uri'     => \$var::Opt{NoEncodeURI} ,
	       'x|no-heading-summary'=> \$var::Opt{NoHeadAbst},
	       'e|robots-txt'        => \$var::Opt{RobotExclude},
	       'q|quiet'             => \$var::Opt{Quiet},
	       'P|no-phrase-index'   => \$var::Opt{NoPhraseIndex},
	       'R|no-regex-index'    => \$var::Opt{NoRegexIndex},
	       'W|no-date-index'     => \$var::Opt{NoDateIndex},
	       'X|no-field-index'    => \$var::Opt{NoFieldIndex},
	       'Y|no-delete'         => \$var::Opt{NoDeleteProcessing},
	       'Z|no-update'         => \$var::Opt{NoUpdateProcessing},
	       'A|htacces'           => \$var::Opt{HtaccessExclude},
	       'd|debug'             => \$var::Opt{Debug},
	       's|checkpoint'        => \$CheckPoint{'on'},
	       'O|output-dir=s'      => \$output_dir,
	       'l|lang=s'            => \$conf::LANGUAGE,
	       'T|template-dir=s'    => \$TEMPLATEDIR,
	       't|allow=s'           => \$conf::ALLOW_REGEX,

	       'v|version'           => \$opt_version,
	       'V|verbose'           => \$var::Opt{verbose},
	       'a|all'               => \$opt_all,
	       'k|use-kakasi'        => \$opt_kakasi,
	       'c|use-chasen'        => \$opt_chasen,
	       'm|use-chasen-morph'  => \$opt_chasen_morph,
	       'r|man'               => \$opt_man,
	       'I|include=s'         => \$opt_include,
	       'F|target-list=s'     => \$opt_target_list,
	       'S|checkpoint-sub'    => \$opt_checkpoint_sub,
	       '0|help'              => \$opt_help,
	       );

    if ($opt_help) {
	show_long_usage();
	exit 0;
    }

    if ($opt_version) {
	print "mknmz v$var::VERSION\n";
	exit 0;
    }

    if ($opt_all) {
	$conf::ALLOW_REGEX = ".*";
    }
    if ($opt_chasen) {
	$conf::WAKATI = $conf::CHASEN;
	$var::Opt{Morph} = 0;
    }
    if ($opt_chasen_morph) {
	$conf::WAKATI = $conf::CHASEN_MORPH;
	$var::Opt{Morph} = 1;
    }
    if ($opt_kakasi) {
	$conf::WAKATI = $conf::KAKASI;
	$var::Opt{Morph} = 0;
    }
    if ($opt_man) {
	$var::Opt{Man}      = 1;
	$conf::ALLOW_REGEX = '.*\.\d.*';
    }
    if ($opt_include) {
	eval util::readfile($opt_include);
        util::dprint("Included: $opt_include\n") unless $var::Opt{Quiet};
    }
    if ($opt_target_list) {
	if ($CheckPoint{'continue'}) {
	    @flist = ("dummy");
	} else {
	    @flist = load_target_list($opt_target_list);
	    util::dprint("Loaded: $opt_target_list\n") unless $var::Opt{Quiet};
	}
	$target_loaded = 1;
	$target_dir = cwd();
    }
    if ($opt_checkpoint_sub) {
	$CheckPoint{'on'}           = 1;
	$CheckPoint{'continue'}     = 1;
	@argv = grep {! /-S/} @argv;  # remove -S
    }

    if (@ARGV == 0 && !$target_loaded && $output_dir eq "") {
	show_mini_usage();
	exit 1;
    }

    if ($target_loaded && ! @flist) {
 	print "No files to index.\n";
 	exit 0;
    }

    if ($#ARGV > 0 || $#ARGV == 0 && $target_loaded) {
	$var::PREFIX = $ARGV[0];
	shift @ARGV;
    }

    $target_dir = $ARGV[0] if defined $ARGV[0];
    $output_dir = cwd() if $output_dir eq "";
    die "$output_dir: invalid output directory\n"
	unless (-d $output_dir && -w $output_dir);

    if ($SYSTEM eq "MSWin32" || $SYSTEM eq "os2") {
	# convert \ to / with consideration for Shift_JIS Kanji code
	$target_dir =~ 
	    s!([\x81-\x9f\xe0-\xef][\x40-\x7e\x80-\xfc]|[\x01-\x7f])!
	    $1 eq "\\" ? "/" : $1!gex;
	$output_dir =~ 
	    s!([\x81-\x9f\xe0-\xef][\x40-\x7e\x80-\xfc]|[\x01-\x7f])!
	    $1 eq "\\" ? "/" : $1!gex;
    }

    # revert @ARGV
    @ARGV = @argv;

    return ($output_dir, $target_dir, @flist);
}


sub load_target_list ($) {
    my ($file) = @_;
    my @flist = ();

    my $cwd = cwd();

    {
	my $fh_tlist = util::efopen($file);
	@flist = <$fh_tlist>;
	chomp @flist; 
    }

    # convert a relative path into an absolute path
    grep(s!^\./!$cwd/!, @flist); 
    if (($SYSTEM eq "MSWin32") || ($SYSTEM eq "os2")) {
        grep(s,^([A-Z](?!:/)),$cwd/$1,i, @flist); 
    } else {
        grep(s!^([^/])!$cwd/$1!, @flist); 
    }

    # traverse directories
    # this routine is not efficent but I prefer reliable logic.
    my @tmp2 = ();
    while (@flist) {
	my $tmp = shift (@flist);
	if ($tmp =~ s!/$!! && -d $tmp) { # path ending with /
	    my $cwd = cwd();
	    chdir $tmp;
	    find::findfiles(\@tmp2);
	    chdir $cwd;
	} else {
	    push(@tmp2, $tmp);
	}
    }
    @flist = @tmp2;

    return @flist;
}


sub show_long_usage () {
    util::dprint("lang: $conf::LANGUAGE\n");
    if ($conf::LANGUAGE eq "ja") {
	if ($CCS eq "euc") {
	    print $usage::USAGE_JA;
	} elsif ($CCS eq "sjis") {
	    my $msg = codeconv::eucjp_to_shiftjis($usage::USAGE_JA);
	    print $msg;
	}
    } else {
	print $usage::USAGE_EN;
    }
}

sub show_mini_usage () {
    print $usage::USAGE_MINI;
}

# check the file -- 0: OK / 1: NG
sub check_file ($$$$) {
    my ($cfile, $content, $size, $mtype) = @_;

    my $msg = "";
    if ($size == 0) {
	$msg = "is 0 size! skipped.";
    } elsif ($mtype =~ /^application\/octet-stream/) {
	$msg = "may be a BINARY file! skipped.";
    } elsif ($size > $conf::FILE_SIZE_LIMIT) {
	$msg = "is too LARGE file! skipped.";
    } elsif ($mtype =~ /^x-system/) {
	$msg = "system error occurred! ($mtype) skipped.";
    } elsif (!$var::Opt{NoMHonArc} && $cfile !~ /($conf::MHONARC_MESSAGE_FILE)$/o 
	     && $$content =~ /^$conf::MHONARC_HEADER/o) {
	$msg = "is MHonArc's index file! skipped.";
    } else {
	$msg = "";
    }

    return $msg;
}


# util::Rename *.$$ to each real file name
sub write_nmz_files () {
    util::Rename($var::File{'INDEX_'},      $var::File{'INDEX'});
    util::Rename($var::File{'INDEXINDEX_'}, $var::File{'INDEXINDEX'});
    util::Rename($var::File{'WORDLIST_'},   $var::File{'WORDLIST'});
    util::Rename($var::File{'PHRASE_'},     $var::File{'PHRASE'});
    util::Rename($var::File{'PHRASEINDEX_'}, $var::File{'PHRASEINDEX'});
}

# output NMZ.body
sub write_body_msg () {
    write_message("$var::File{'BODYMSGFILE'}.ja", $var::File{'BODY_MSG_JA'});
    write_message("$var::File{'BODYMSGFILE'}.en", $var::File{'BODY_MSG_EN'});
}

# output NMZ.result
sub write_result_file () {
    my $file = $var::File{'RESULTFILE'};

    if (-e $file) {
	return;
    } 

    $file =~ m!.*/(.*)$!;
    my $fname = $1;
    my $template = "";
    my $buf = "";

    my $templatedir2 = cwd() . "/../template";  # relative path from cwd
    if ($TestMode && -e "$templatedir2/$fname") {
	$template = "$templatedir2/$fname";
    } else {
	$template = "$TEMPLATEDIR/$fname";
    }
    if (-e $template) {
	$buf = util::readfile($template);
    } else {
	return;
    }

    # the file must be saved in ISO-2022-JP encoding.
    my $fh_file;
    if ($conf::LANGUAGE eq "ja" && !$var::USE_NKF_MODULE) {
	$fh_file = util::efopen("|$conf::NKF -j >$file");
    } else {
	$fh_file = util::efopen(">$file");
    }

    $buf = NKF::nkf("-j", $buf) if $var::USE_NKF_MODULE;
    print $fh_file $buf;
}

# write NMZ.body and etc.
sub write_message ($$) {
    my ($full_path_name, $msg) = @_;

    if (! -e $full_path_name) {
	my ($template, $fname);
	
	$full_path_name =~ m!.*/(.*)$!;
	$fname = $1;
	my $templatedir2 = cwd() . "/../template";  # relative path from cwd
	if ($TestMode && -e "$templatedir2/$fname") {
	    $template = "$templatedir2/$fname";
	} else {
	    $template = "$LIBDIR/$fname";
	}
	if (-e $template) {
	    my $buf = util::readfile($template);
	    my $fh_output;
	    if ($conf::LANGUAGE eq "ja" && !$var::USE_NKF_MODULE) {
		$fh_output = util::efopen("|$conf::NKF -j >$full_path_name");
	    } else {
		$fh_output = util::efopen(">$full_path_name");
	    }
	    $buf =~ s/"/\\"/g;
	    $buf =~ s/\@/\\@/g;
	    $buf = eval("\"$buf\"");  # eval to interpolate variables in $buf
	    $buf = NKF::nkf("-j", $buf) if $var::USE_NKF_MODULE;

	    print $fh_output $buf;
	}
    }
}


# Make a file for logging
sub make_slog_file () {
    {
	my $fh_slogfile = util::efopen(">>$var::File{'SLOGFILE'}");
    }
    chmod 0666, $var::File{'SLOGFILE'};
}


# concatenate $CURRENTDIR to head of each files
sub change_dbnames ($) {
    my ($current_dir) = @_;

    for my $key (sort keys %var::File) {
	next if $key =~ /^TMP/;  # exclude temporary file
	next if $key =~ /_$/;    # exclude temporary file
	$var::File{$key} = "$current_dir/$var::File{$key}";
    }

    # temporary files
    for my $key (sort keys %var::File) {
	if ($key =~ /^TMP/ || $key =~ /_$/) {
	    $var::File{$key} = "$current_dir/$var::File{$key}.$$";
	}
    }
}


# for `find'
sub wanted ($$){
    my ($name, $rarray) = @_;
    push(@{$rarray}, $name) if 
	($name !~ m!^.*/(($conf::DENY_REGEX)(\.gz|\.Z)?)$!i &&
	 $name =~ m!^.*/(($conf::ALLOW_REGEX)(\.gz|\.Z|\?.*)?)$!i && -f $name && -r $name);
}

#
# preparation processing for appending index files
#
sub append_index (@) {
    my @flist = @_;

    my $file_base = 0;
    ($file_base, @flist) = set_target_files(@flist);

    unless (@flist) { 	# if @flist is empty
	if ($DeletedFilesCount > 0) {
	    make_headfoot_pages(0, 0);
	    set_lockfile($var::File{LOCKFILE2});
	    update_dateindex();
	    update_registry(0);
	    put_log(0, 0, 0, get_total_keys());
	    remove_lockfile($var::File{LOCKFILE2});
	}
	print "No files to index.\n";
	exit 0;
    }

    $APPENDMODE = 1;
    # ファイルをコピーして保護する
    util::cp($var::File{'INDEX'},      $var::File{'INDEX_'});
    util::cp($var::File{'DATEINDEX'},  $var::File{'DATEINDEX_'}) unless -e $var::File{'DATEINDEX_'}; # preupdated ?

    unless ($var::Opt{NoPhraseIndex}) {
	util::cp($var::File{'PHRASE'},      $var::File{'PHRASE_'});
	util::cp($var::File{'PHRASEINDEX'},      $var::File{'PHRASEINDEX_'});
    }

    return ($file_base, @flist);
}

# set target files to @flist and return with the regiested files number
sub set_target_files() {
    my %rfiles;    # 'rfiles' means 'registered files'
    my @found_files = @_;

    # load the list of registered files
    $rfiles{'name'} = [ load_registry() ];

    # pick up overlap files and do marking
    my %mark1;
    my @overlapped_files;
    grep($_ !~ /^\# / && $mark1{$_}++, @{$rfiles{'name'}});
    $rfiles{'overlapped'} = {}; # prepare an anonymous hash
    for (grep ($mark1{$_}, @found_files)) {
	$rfiles{'overlapped'}{$_} = 1;
	push(@overlapped_files, $_);
    };
    # pick up not overlapped files which are files to index
    my @flist = grep(! $mark1{$_}, @found_files);
	 
    if ($var::Opt{NoUpdateProcessing}) {
	return (scalar @{$rfiles{'name'}}, @flist);
    };

    # load the date index
    $rfiles{'mtime'} = [ load_dateindex() ];

    if (@{$rfiles{'mtime'}} == 0) {
	return (scalar @{$rfiles{'name'}}, @flist); 
    };

    if ($#{$rfiles{'name'}} != $#{$rfiles{'mtime'}}) {
	util::dprint("\n\n== registered ==\n", join("\n", @{$rfiles{'name'}}));
	util::dprint("\n\n== mtimes ==\n", join("\n", @{$rfiles{'mtime'}}));
	die "NMZ.r ($#{$rfiles{'name'}}) and NMZ.t ($#{$rfiles{'mtime'}})"
	    . "are not consistent!\n";
    }

    # pick up deleted files and do marking
    # (registered in the NMZ.r but not existent in the filesystem)
    my @deleted_files;
    unless ($var::Opt{NoDeleteProcessing}) {
	my %mark2;
	grep($mark2{$_}++, @found_files);
	for (grep($_ !~ /^\# / && ! $mark2{$_} && ! $rfiles{'overlapped'}{$_}
		      , @{$rfiles{'name'}})) 
	{
	    $rfiles{'deleted'}{$_} = 1;
	    push(@deleted_files, $_);
	}
    }

    # pick up updated files and set the missing number for deleted files
    my @updated_files = pickup_updated_files(\%rfiles);

    # append updated files to list of files to index
    if (@updated_files) {
	push(@flist, @updated_files);
    }

    util::dprint("\n\n== found ==\n", join("\n", @found_files), "\n");
    util::dprint("\n\n== registered ==\n", join("\n", @{$rfiles{'name'}}), "\n");
    util::dprint("\n\n== overlapped  ==\n", join("\n", @overlapped_files), "\n");
    util::dprint("\n\n== deleted  ==\n", join("\n", @deleted_files), "\n");
    util::dprint("\n\n== updated ==\n", join("\n", @updated_files), "\n");
    util::dprint("\n\n== files to index ==\n", join("\n", @flist), "\n");

    # update NMZ.t with the missing number infomation and
    # append updated files and deleted files to NMZ.r with leading '# '
    if (@updated_files || @deleted_files) {
	$DeletedFilesCount = 0;
	$UpdatedFilesCount = 0;
	$UpdatedFilesCount += @updated_files;
#	$DeletedFilesCount += @updated_files;
	$DeletedFilesCount += @deleted_files;
	preupdate_dateindex(@{$rfiles{'mtime'}});
	preupdate_registry(@updated_files, @deleted_files);
    }

    # return with number of registered files and list of files to index
    return (scalar @{$rfiles{'name'}}, @flist);
}

sub preupdate_registry(@) {
    my (@list) = @_;

    my $fh_registry = util::efopen(">$var::File{'REGISTRY_'}");
    @list = grep(s/(.*)/\# $1\n/, @list);
    print $fh_registry @list;
    print $fh_registry "## deleted: " . util::rfc822time(time()) . "\n\n";
}

sub preupdate_dateindex(@) {
    my @mtimes = @_;

    # Since rewriting the entire file, it is not efficient, 
    # but simple and reliable. this would be revised in the future.
    my $fh_dateindex = util::efopen(">$var::File{'DATEINDEX_'}");
#    print "\nupdate_dateindex\n", join("\n", @mtimes), "\n\n";
    print $fh_dateindex pack("N*", @mtimes);
}

sub update_registry ($) {
    my ($file_count) = @_;

    {
	my $fh_registry = util::efopen(">>$var::File{'REGISTRY'}");
	my $fh_registry_ = util::efopen($var::File{'REGISTRY_'});
	while (<$fh_registry_>) {
	    print $fh_registry $_;
	}
	if ($file_count > 0) {
	    print $fh_registry "## indexed: " . util::rfc822time(time()) . "\n\n";
	}
    }
    unlink $var::File{'REGISTRY_'};
}

sub update_dateindex () {
    util::Rename($var::File{'DATEINDEX_'}, $var::File{'DATEINDEX'});
}

sub update_field_index () {
    update_field_index_sub(glob "$var::File{'FIELDINFO'}.*.$$");
    update_field_index_sub(glob "$var::File{'FIELDINFO'}.*.i.$$");
}

sub update_field_index_sub () {
    my @list = @_;
    for my $tmp (@list) {
	$tmp =~ /((.*)\.$$)/;
	my $fname_tmp = $1;
	my $fname_out = $2;

	{
	    my $fh_field = util::efopen(">>$fname_out");
	    my $fh_tmp = util::efopen($fname_tmp);

	    while (<$fh_tmp>) {
		print $fh_field $_;
	    }
	}
	unlink $fname_tmp;
    }
}

sub pickup_updated_files (\%) {
    my ($ref) = @_;
    my @updated_files = ();

    my $i = 0;
    for my $cfile (@{$ref->{'name'}}) {
	if (defined($ref->{'deleted'}{$cfile})) {
	    print "$cfile was deleted!\n" unless $var::Opt{Quiet};
	    $ref->{'mtime'}[$i] = -1; # assign the a messing number
	} elsif (defined($ref->{'overlapped'}{$cfile})) {
	    my $cfile_mtime = (stat($cfile))[9];
	    my $rfile_mtime = $ref->{'mtime'}[$i];

	    if ($rfile_mtime < $cfile_mtime) {
		# this file is updated!
		print "$cfile was updated!\n" unless $var::Opt{Quiet};
		$ref->{'mtime'}[$i] = -1; # assign the messing number
		push(@updated_files, $cfile);
	    }
	}
	$i++;
    }

    return @updated_files
}

sub load_dateindex() {
    my $fh_dateindex = util::efopen($var::File{'DATEINDEX'});

    my $size = (stat($var::File{'DATEINDEX'}))[7];
    my $buf  = "";
    read($fh_dateindex, $buf, $size);
    my @list = unpack("N*", $buf);  # load date index
#    print "\nload_dateindex\n", join("\n", @list), "\n\n";

    return @list;
}

sub load_registry () {
    my @list = ();

    my $fh_registry = util::efopen($var::File{'REGISTRY'});

    my $i = 0;
    my %mark;
    while (<$fh_registry>) {
	my $line = $_;
	chomp($line);
	next if /^\s*$/; # an empty line
	next if /^##/; # a comment
	if (/^\#\s+(.*)/) {  # deleted document
	    my $tmp = $1;
	    # remove previous registration
	    if (defined($mark{$tmp})) {
		splice(@list, $mark{$tmp}, 1, "# $tmp");
		undef $mark{$tmp};
	    } else {
		die "ERROR: malformed NMZ.r format!\n";
	    }
	} else {
	    unless (defined($mark{$line})) {
		push(@list, $line);
		$mark{$line} = $i;
		$i++;
	    } 
	}
    }
    return @list;
}

sub get_total_keys() {
    return get_number_from_file($var::File{'TOTALKEYSCOUNT'});
}

sub get_total_files() {
    return get_number_from_file($var::File{'TOTALFILESCOUNT'});
}

sub get_number_from_file ($) {
    my ($file) = @_;

    return 0 unless -f $file;

    my $fh = util::efopen($file);
    my $number = "";
    $number = <$fh>;
    chomp $number;
    $number =~ s/,//g;

    if ($number eq "") {
	return 0;
    } else {
	return $number;
    }
}

sub put_total_files($) {
    my ($number) = @_;
    put_number_to_file($var::File{'TOTALFILESCOUNT'}, $number);
}

sub put_total_keys($) {
    my ($number) = @_;
    put_number_to_file($var::File{'TOTALKEYSCOUNT'}, $number);
}

sub put_number_to_file ($$) {
    my ($file, $number) = @_;
    $number =~ s/,//g;

    my $fh = util::efopen(">$file");
    print $fh $number, "\n";
}


# do logging
sub put_log ($$$$) {
    my ($total_files_size, $start_time, $file_count, $total_keys_count) = @_;

    my $argv = join(' ', map {"'$_'"} @ARGV);
    my $date = localtime;
    my $added_files_count   = util::commas($file_count - $UpdatedFilesCount);
    my $deleted_files_count = util::commas($DeletedFilesCount);
    my $updated_files_count = util::commas($UpdatedFilesCount);
    my $total_files_count   = util::commas(get_total_files() + $file_count 
					   - $DeletedFilesCount - $UpdatedFilesCount);
    my $added_keys_count    = 0;
    $added_keys_count       = util::commas($total_keys_count - get_total_keys());

    my $processtime         = time - $start_time;
    $processtime            = 0 if $start_time == 0;
    $total_files_size        = util::commas($total_files_size);
    $total_keys_count       = util::commas($total_keys_count);

    my $logmsg = "[Base]\n";
    $logmsg = "[Append]\n" if $APPENDMODE;
    $logmsg .= "Date: $date\n" if $date;
    $logmsg .= "Added Files: $added_files_count files\n" if $added_files_count;
    $logmsg .= "Deleted Files: $deleted_files_count files\n" if $deleted_files_count;
    $logmsg .= "Updated Files: $updated_files_count files\n" if $updated_files_count;
    $logmsg .= "Total Files: $total_files_count files\n" if $total_files_count;
    $logmsg .= "Size: $total_files_size bytes\n" if $total_files_size;
    $logmsg .= "Added Keywords: $added_keys_count words\n" if $added_keys_count;
    $logmsg .= "Total Keywords: $total_keys_count words\n" if $total_keys_count;
    $logmsg .= "Wakati: $conf::WAKATI\n" if $conf::WAKATI;
    $logmsg .= "ARGV: $argv\n" if $argv;
    $logmsg .= "Perl Version: $]\n" if $];   # '$]' has a perl version
    $logmsg .= "Namazu Version: $var::VERSION\n" if $var::VERSION;
    $logmsg .= "System: $SYSTEM\n" if $SYSTEM;
    $logmsg .= "Time: $processtime sec.\n"if $processtime;
    $logmsg .= "\n";

    print $logmsg unless $var::Opt{Quiet};
    put_log_to_logfile($logmsg);
    put_total_files($total_files_count);
    put_total_keys($total_keys_count);
}

sub put_log_to_logfile ($) {
    my ($logmsg) = @_;
    my $fh_logfile = util::efopen(">>$var::File{'LOGFILE'}");
    print $fh_logfile $logmsg;
}

sub get_year() {
    my $year = (localtime)[5] + 1900;

    return $year;
}

# ヘッダとフッタの処理。ファイルがなければサンプルを作成する。
# また $file_count, $key_count, $month/$day/$year を埋め込む
sub make_headfoot ($$$) {
    my ($file, $file_count, $key_count) = @_;

    my $day   = sprintf("%02d", (localtime)[3]);
    my $month = sprintf("%02d", (localtime)[4] + 1);
    my $year  = get_year();
    my $buf   = "";

    if (-e $file) {
	$buf = util::readfile($file);
    } else {
	$file =~ m!.*/(.*)$!;
	my $fname = $1;
	my $template = "";
	my $templatedir2 = cwd() . "/../template";  # relative path from cwd
	if ($TestMode && -e "$templatedir2/$fname") {
	    $template = "$templatedir2/$fname";
	} else {
	    $template = "$TEMPLATEDIR/$fname";
	}
	if (-e $template) {
	    $buf = util::readfile($template);
	} else {
	    return;
	}
	$buf =~ s/"/\\"/g;
	$buf =~ s/\@/\\@/g;
	$buf = eval("\"$buf\"");
    }

    # the file must be saved in ISO-2022-JP encoding.
    my $fh_file;
    if ($conf::LANGUAGE eq "ja" && !$var::USE_NKF_MODULE) {
	$fh_file = util::efopen("|$conf::NKF -j >$file");
    } else {
	$fh_file = util::efopen(">$file");
    }

    if ($buf =~ /(<!-- FILE -->)\s*(.*)\s*(<!-- FILE -->)/) {
	my $total_files_count = util::commas(get_total_files() + $file_count 
				   - $DeletedFilesCount - $UpdatedFilesCount);
	$buf =~ s/(<!-- FILE -->)(.*)(<!-- FILE -->)/$1 $total_files_count $3/;

    }
    if ($buf =~ /(<!-- KEY -->)\s*(.*)\s*(<!-- KEY -->)/) {
	my $tmp = $2;
	$tmp =~ tr/,//d;
	$tmp = $key_count;
	$tmp = util::commas($tmp);
	$buf =~ s/(<!-- KEY -->)(.*)(<!-- KEY -->)/$1 $tmp $3/;
    }
    $buf =~ s#(<!-- DATE -->)(.*)(<!-- DATE -->)#$1 $year-$month-$day $3#g;
    $buf =~ s/(<!-- VERSION -->)(.*)(<!-- VERSION -->)/$1 v$var::VERSION $3/g;

    $buf = NKF::nkf("-j", $buf) if $var::USE_NKF_MODULE;
    print $fh_file $buf;
}

# make phrase hashes for NMZ.p
# 2単語の組でひとつのハッシュ値 (0-65535) を生成します
sub make_phrase_hash ($$$) {
    my ($file_count, $file_base, $content) = @_;

    my %tmp = ();
    $$content =~ s!\x7f */? *\d+ *\x7f!!g;  # remove tags of weight
    my @words = split(/\s+/, $$content);
    @words = grep(!/^$/, @words);   # remove empty words
    my $word_b = $words[0];
    my $fid = $file_count + $file_base;
    for my $word (@words) {
	my $hash = hash($word_b . $word);
	unless (defined $tmp{$hash}) {
	    $tmp{$hash} = 1;
	    $PhraseHashLast{$hash} = 0 unless defined $PhraseHashLast{$hash};
	    $PhraseHash{$hash} .= pack("w", $fid - $PhraseHashLast{$hash});
#	    util::dprint("<$word_b, $word> $hash\n");
	    $PhraseHashLast{$hash} = $fid;
	}
	$word_b = $word;
    }
}

# NMZ.p, NMZ.pi ファイルへ書き出し & マージする (複雑)
sub write_phrase_hash () {
    write_phrase_hash_sub();
    util::Rename($var::File{'TMP_P'}, $var::File{'PHRASE_'});
    util::Rename($var::File{'TMP_PI'}, $var::File{'PHRASEINDEX_'});
}

sub write_phrase_hash_sub () {
    my $opened = 0;

    return 0 if %PhraseHash eq "0";
    util::dprint("doing write_phrase_hash() processing.\n");

    my $fh_tmp_pi = util::efopen(">$var::File{'TMP_PI'}");
    my $fh_tmp_p  = util::efopen(">$var::File{'TMP_P'}");

    my $fh_phrase = util::fopen($var::File{'PHRASE_'});
    my $fh_phraseindex;
    if ($fh_phrase) {
	$fh_phraseindex = util::efopen($var::File{'PHRASEINDEX_'});
	$opened = 1;
    }
	
    my $ptr = 0;
    for (my $i = 0; $i < 65536; $i++) {

	my $baserecord = "";
	my $baseleng = 0;

	if ($opened) {
	    my $tmp = 0;
	    read($fh_phraseindex, $tmp, $var::INTSIZE);
	    $tmp = unpack("N", $tmp);
	    if ($tmp != 0xffffffff) { # 0xffffffff
		$baseleng = get_unpackw($fh_phrase);
		read($fh_phrase, $baserecord, $baseleng);
	    }
	}
	if (defined($PhraseHash{$i})) {
	    if ($baserecord eq "") {
		print $fh_tmp_pi pack("N", $ptr);
		my $record = $PhraseHash{$i};
		my $n2 = length($record);
		my $data = pack("w", $n2) . $record;
		print $fh_tmp_p $data;
		$ptr += length($data);
	    } else {
		print $fh_tmp_pi pack("N", $ptr);
		my $record = $PhraseHash{$i};
		my $last_fid = get_last_fid($baserecord, 1);
		$record = adjust_first_fid($record, $last_fid);
		my $n2 = length($record) + $baseleng;
		my $data = pack("w", $n2) .  $baserecord . $record;
		print $fh_tmp_p $data;
		$ptr += length($data);
	    }
	} else {
	    if ($baserecord eq "") {
		# if $baserecord has no data, set to 0xffffffff
		print $fh_tmp_pi pack("N", 0xffffffff);
	    } else {
		print $fh_tmp_pi pack("N", $ptr);
		my $data = pack("w", $baseleng) . $baserecord;
		print $fh_tmp_p $data;
		$ptr += length($data);
	    }
	}
    }
    %PhraseHash = ();
    %PhraseHashLast = ();
}

# Dr. Knuth's  ``hash'' from (UNIX MAGAZINE May 1998)
sub hash ($) {
    my ($word) = @_;
    my ($i, $hash);

    $hash = 0;
    $word =~ tr/\xa1-\xfea-z0-9//cd; # 記号を捨てる
    for ($i = 0; $word ne ""; $i++) {
	$hash ^= $seed::Seed[$i & 0x03][ord($word)];
        $word = substr $word, 1;
	# $word =~ s/^.//;  is slower
    }
    $hash & 65535;
}

# 単語の頻度数を数える
sub count_words ($$$$) {
    my ($file_count, $file_base, $content, $kanji) = @_;
    my (@tmp);

    # 小文字に正規化
    $$content =~ tr/A-Z/a-z/;

    # わかち書き
    if ($conf::LANGUAGE eq "ja") {
	wakati::wakatize_japanese($content) if $kanji;
    }

    # 記号を全て削除する -K オプション時
    $$content =~ tr/\xa1-\xfea-z0-9/   /c if $var::Opt{NoSymbol};

    my $part1 = "";
    my $part2 = "";
    if ($$content =~ /\x7f/) {
	$part1 = substr $$content, 0, index($$content, "\x7f");
	$part2 = substr $$content, index($$content, "\x7f");
#	$part1 = $PREMATCH;  # $& and friends are not efficient
#	$part2 = $MATCH . $POSTMATCH;
    } else {
	$part1 = $$content;
	$part2 = "";
    }

    # do scoring
    my %word_count = ();
    $part2 =~ s!\x7f *(\d+) *\x7f([^\x7f]*)\x7f */ *\d+ *\x7f!
	wordcount_sub($2, $1, \%word_count)!ge;
    wordcount_sub($part1, 1, \%word_count);

    # Add them to whole index
    my $fid = $file_count + $file_base;
    for my $word (keys(%word_count)) {
	next if ($word eq "" || length($word) > $conf::WORD_LENG_MAX);
	$KeyIndexLast{$word} = 0 unless defined $KeyIndexLast{$word};
	$KeyIndex{$word} .= pack("w2", 
				 $fid - $KeyIndexLast{$word}, 
				 $word_count{$word});
	$KeyIndexLast{$word} = $fid;
    }
}

# count words and do score weighting
sub wordcount_sub ($$\%) {
    my ($text, $weight, $word_count) = @_;

    # カレントファイルの単語の出現回数を調べる
    # 記号をそれなりに処理する
    # tutil::cp/ip なら tutil::cp/ip, tutil::cp, ip と 3 つに分解される
    # (tutil::cp/ip) なら (tutil::cp/ip), tutil::cp/ip, tutil::cp, ip の 4 つなる
    # ((tutil::cpi/ip)) なら ((tutil::cp/ip)), (tutil::cp/ip), tutil::cp, ip の 4 つになる
    # 入れ子処理は行わない
    # ただし -K オプション指定時は記号はすべて削除している

    my @words = split /\s+/, $text;
    @words = grep !/^$/, @words;   # remove empty words
    my @words_ = ();
    for my $word (@words) {
	if ($var::Opt{NoEdgeSymbol}) {
	    # remove symbols at both ends
	    $word =~ s/^[^\xa1-\xfea-z_0-9]*(.*?)[^\xa1-\xfea-z_0-9]*$/$1/g;
	}
	$word_count->{$word} = 0 unless defined($word_count->{$word});
	$word_count->{$word} += $weight;
	unless ($var::Opt{NoSymbol}) {
	    if ($word =~ /^[^\xa1-\xfea-z_0-9](.+)[^\xa1-\xfea-z_0-9]$/) {
		$word_count->{$1} = 0 unless defined($word_count->{$1});
		$word_count->{$1} += $weight;
		next unless $1 =~ /[^\xa1-\xfea-z_0-9]/;
	    } elsif ($word =~ /^[^\xa1-\xfea-z_0-9](.+)/) {
		$word_count->{$1} = 0 unless defined($word_count->{$1});
		$word_count->{$1} += $weight;
		next unless $1 =~ /[^\xa1-\xfea-z_0-9]/;
	    } elsif ($word =~ /(.+)[^\xa1-\xfea-z_0-9]$/) {
		$word_count->{$1} = 0 unless defined($word_count->{$1});
		$word_count->{$1} += $weight;
		next unless $1 =~ /[^\xa1-\xfea-z_0-9]/;
	    }
	    push(@words_, split(/[^\xa1-\xfea-z_0-9]+/, $word))
		if $word =~ /[^\xa1-\xfea-z_0-9]/;
	    @words_ = grep !/^$/, @words_;   # remove empty words
	    for my $tmp (@words_) {
		next if $tmp eq "";
		$word_count->{$tmp} = 0 unless defined($word_count->{$tmp});
		$word_count->{$tmp} += $weight;
	    }
	    @words_ = ();
	}
    }
    return "";
}


# 文字列の unsigned な比較ルーチン。
# このルーチンは古川@ヤマハさんがくださりました
# ほんの少し改変 v1.1.1.3 [1998-02-27]
# sub unsignedcmp {
#     my ($str1, $str2) = @_;
#     my ($ord1, $ord2);
#     while (($ord1 = ord($str1)) == ($ord2 = ord($str2))) {
#         last if ! $ord1;
#         $str1 =~ s/^.//;
#         $str2 =~ s/^.//;
#     }
#     $ord1 <=> $ord2;
# }

# make NMZ.i and NMZ.ii file. this processing is rather complex.
sub write_index () {
    my $key_count = write_index_sub();
    util::Rename($var::File{'TMP_I'}, $var::File{'INDEX_'});
    util::Rename($var::File{'TMP_W'}, $var::File{'WORDLIST_'});

    return $key_count;
}

# this is very inefficient
sub get_unpackw ($) {
    my ($fh) = @_;

    my $val = 0;
    while (1) {
	my $tmp = getc($fh);
        die "fatal error occurred in get_unpackw\n" unless defined $tmp;
	$tmp = ord($tmp);

	if ($tmp < 128) {
	    $val += $tmp;
	    return $val;
	} else {
	    $tmp &= 0x7f;
	    $val += $tmp;
	    $val <<= 7;
	}
    }
}

sub get_last_fid ($$) {
    my ($record, $step) = @_;
    my (@data) = unpack 'w*', $record;

    my $sum = 0;
    for (my $i = 0; $i < @data; $i += $step) {
	$sum += $data[$i];
    }
    my $leng = @data / $step;
    return $sum;
}

sub adjust_first_fid ($$) {
    my ($record, $last_fid) = @_;
    my (@data) = unpack 'w*', $record;

    my $val = $data[0];
    $data[0] = $data[0] - $last_fid;
    my $adjusted = $val - $last_fid;
    $record = pack 'w*', @data;
    return $record;
}

sub write_index_sub () {
    my @words = sort keys(%KeyIndex);
    return 0 if $#words == -1;

    util::dprint("doing write_index() processing.\n");
    my $fh_indexindex = util::efopen(">$var::File{'INDEXINDEX_'}");
    my $fh_tmp_i = util::efopen(">$var::File{'TMP_I'}");
    my $fh_tmp_w = util::efopen(">$var::File{'TMP_W'}") unless $var::Opt{NoRegexIndex};

    my $cnt = 0;
    my $ptr = 0;
    my $key_count = 0;
    my $baserecord = "";

    my $fh_index = util::fopen($var::File{'INDEX_'});
    if ($fh_index) {
      FOO:
	while (<$fh_index>) {
	    my $current_word = $_;
	    chop $current_word;

	    my $baseleng = get_unpackw($fh_index);
	    read($fh_index, $baserecord, $baseleng);
	    <$fh_index>;

 	    for (; $cnt < @words; $cnt++) {
		last unless $words[$cnt] le $current_word;
		my $record = $KeyIndex{$words[$cnt]};
		my $leng = length($record);

		if ($current_word eq $words[$cnt]) {
		    my $last_fid = get_last_fid($baserecord, 2);
		    $record = adjust_first_fid($record, $last_fid);
		    $leng = length($record);  # re-measure
		    my $tmp = pack("w", $leng + $baseleng);

		    my $data = "$current_word\n$tmp$baserecord$record\n";
		    print $fh_tmp_w "$current_word\n"
			unless $var::Opt{NoRegexIndex};
		    print $fh_tmp_i $data;
		    print $fh_indexindex pack("N", $ptr);
		    $ptr += length($data);
		    $key_count++;

		    $cnt++;
		    next FOO;
		} else {
		    my $tmp = pack("w", $leng);
		    my $data = "$words[$cnt]\n$tmp$record\n";
		    print $fh_tmp_w "$words[$cnt]\n"
			unless ($var::Opt{NoRegexIndex});
		    print $fh_tmp_i $data;
		    print $fh_indexindex pack("N", $ptr);
		    $ptr += length($data);
		    $key_count++;
		}
	    }
	    my $tmp  = pack("w", $baseleng);
	    my $data = "$current_word\n$tmp$baserecord\n";
	    print $fh_tmp_w "$current_word\n"
		unless $var::Opt{NoRegexIndex};
	    print $fh_tmp_i $data;
	    print $fh_indexindex pack("N", $ptr);
	    $ptr += length($data);
	    $key_count++;
	}
    }
    while ($cnt < @words) {
	my $leng = length($KeyIndex{$words[$cnt]});
	my $tmp = pack("w", $leng);
	my $record = $KeyIndex{$words[$cnt]};

	my $data = "$words[$cnt]\n$tmp$record\n";
	print $fh_tmp_w "$words[$cnt]\n"
	    unless $var::Opt{NoRegexIndex};
	print $fh_tmp_i $data;
	print $fh_indexindex pack("N", $ptr);
	$ptr += length($data);
	$key_count++;
	$cnt++;
    }
    %KeyIndex = ();
    %KeyIndexLast = ();

    return $key_count;
}

# decide file type from diffrent type ditection
sub decide_type ($$) {
    my ($name, $cont) = @_;
    return $name if ($name eq $cont);

    if ($cont =~ /^text/ && $name =~ /.*;.*x-type=(rfc|internet-draft|fyi)/) {
	return $name;
    }

    return $cont;
}

# for avoiding "used only once: possible typo at ..." warnings

muda($var::File{'BODY_MSG_EN'},
     $conf::SEARCH_FIELD, $conf::ON_MEMORY_MAX,
     $var::File{'BODY_MSG_JA'}, $conf::WORD_LENG_MAX,
     $conf::MHONARC_MESSAGE_FILE, $conf::DENY_REGEX, $var::INTSIZE,
     $var::Opt{MailNews}, $var::Opt{NoLineAd}, $conf::CHASEN_MORPH,
     $var::Opt{Uuencode}, $conf::MHONARC_HEADER, $conf::CHASEN,
     $conf::KAKASI, $var::Opt{Okurigana}, $TARGET_DIR, $var::Opt{Man},
     $var::Opt{Hiragana}, $conf::ROBOTS_EXCLUDE_URLS, $conf::DEFAULT_FILE,
     $conf::HTML_SUFFIX, $usage::USAGE_EN, $usage::USAGE_MINI, 
     $var::Opt{NoHeadAbst}, @seed::Seed,
     $var::Opt{Debug}, $var::Opt{NoEncodeURL}, $var::Opt{HtaccessExclude}, 
     $var::RECURSIVE_ACTIONS, $conf::ROBOTS_EXCLUDE_URIS, 
     $var::Opt{NoInsertHeader}, $var::Opt{NoRegexpIndex}, 
     $var::Opt{NoFieldInfo}, $conf::FILE_SIZE_LIMIT,
     $conf::ROBOTS_EXCLUDE_URLS, $conf::Supported);


sub muda(@) {}

